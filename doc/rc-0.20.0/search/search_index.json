{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Code coverage - Backend: - Frontend: - Example code: Open Banking Gateway Provides tools, adapters and connectors for transparent access to open banking apis. The initial effort focuses on the connectivity to banks that implement the European PSD2 directive either through one of the common market initiatives like : The Berlin Group NextGenPSD2 , The Open Banking UK , The Polish PSD2 API or even through proprietary bank api like the ING\u2019s PSD2 API . What this Project is about Tackle the Key Challenge for Third Party Providers of Payment Services The European PSD2 as the first regulator driven Open Banking initiative offers many opportunities for both banks, known as traditional provider of payment services (called ASPSPs in this context) and other Third Party Providers of payment services (TPPs). TPPs can use account information and payment services provided by banks to offer new innovative services to bank account holders. The more banks and TPPs can interact with each other, the more payment account holders can be provided with reacher banking solutions, which in turn simplifies and leverage commercial value chains. Being able to interact with different banking APIs can be a time and cost consuming challenge. Even though the PSD2 requires European banks to provide APIs and despite the effort of market initiatives to provide common standard interfaces, there is still a multitude of divergent authorization schemes involved and a lot of space for implementation options. A bank can even decide not to join one of the known market initiatives and define it's own PSD2 compliant API. The purpose of this open banking gateway is to provide the community with a common and simple interface for accessing major Open Banking APIs. Introducing the FinTech as a Major Role Being a regulator driven initiative, PSD2 mandates the regulation of TPPs. With this additional detail, the market is experiencing a distinction between regulated TPPs and non regulated FinTechs. This framework is therefore designed taking in consideration the existence of the category of payment service providers called FinTech that used APIs exposed by a regulated TPP to access payment services exposed by banks. Address Security Issues associated with PSU Access to Multiple Interfaces In the Open Banking Context, a payment service user (PSU or banking account holder) might have to deal with up to 3 different user interface to initiate, authorize and get the requested banking service executed. There being redirected back and forth from one UserAgent (resp. device) to another. This intensive use of redirection in Open Banking bearing a lot of risk of impersonating the PSU, we set a goal of this Framework to dissect the complexity involved with those redirection processes and open forums for discussion of possible solutions and sample implementations. Following papers are the first attempt to capture the problem ( UserAgent Redirection , PSU Access Security Design ). Project Demo Demo deployment and guide Big Picture The following picture displays the overall architecture of this banking gateway: Security concept The following picture displays the overall security concept of this banking gateway: Security concept has 2 kinds of flows: - authenticated (for consent sharing) - anonymous (for payments, but can be authenticated too). Here are detailed diagrams of each flow: - Authenticated security concept detailed flow - Anonymous security concept detailed flow Technical architecture The following picture displays the overall technical architecture concept of this banking gateway: Key components as shown on diagram : APIs: - Banking API and its implementation Banking API Impl - Consent API and its implementation Consent API Impl Facade: - Banking protocol facade Protocol: - Banking protocol API - XS2A compliant banking protocol Impl Running the project locally docker-compose-dev.yml - docker-compose file in the project root for Development (requires building docker images) docker-compose.yml - docker-compose file in the project root for Demo (Images will be pulled from DockerHub) Information for developers: Working with BPMN: As most protocols use BPMN, we have developed the plugin 'Flowable BPMN visualizer' that directly integrates into IntelliJ with code navigation, refactoring and other stuff for Flowable BPMN engine . It will make your work a lot easier as you don't need to leave IntelliJ to change diagram or to see what class is used at which step. Starting with project: How to start with project Populating database with bank data: How to fill database with bank data Documentation Please take a look into our documentation to know more about: Planned and released versions Versioning, Release and Support policy Release notes Roadmap for next features development Architecture Dictionary Use Cases Banking Proto\u0441ol Design User Agent Redirection PSU Access Security Design JavaDoc Third Parties Contribution This project is designed to enable contribution from different sources, as the open banking challenge will start with a magnitude of discrepancies in individual bank implementations, even for banks implementing a common standards. How to contribute Getting started Contribution Guidelines Authors & Contact Francis Pouatcha - Initial work - adorsys See also the list of contributors who participated in this project. For commercial support please contact adorsys Team . License This project is licensed under the Apache License version 2.0 - see the LICENSE file for details","title":"Home"},{"location":"#open-banking-gateway","text":"Provides tools, adapters and connectors for transparent access to open banking apis. The initial effort focuses on the connectivity to banks that implement the European PSD2 directive either through one of the common market initiatives like : The Berlin Group NextGenPSD2 , The Open Banking UK , The Polish PSD2 API or even through proprietary bank api like the ING\u2019s PSD2 API .","title":"Open Banking Gateway"},{"location":"#what-this-project-is-about","text":"","title":"What this Project is about"},{"location":"#tackle-the-key-challenge-for-third-party-providers-of-payment-services","text":"The European PSD2 as the first regulator driven Open Banking initiative offers many opportunities for both banks, known as traditional provider of payment services (called ASPSPs in this context) and other Third Party Providers of payment services (TPPs). TPPs can use account information and payment services provided by banks to offer new innovative services to bank account holders. The more banks and TPPs can interact with each other, the more payment account holders can be provided with reacher banking solutions, which in turn simplifies and leverage commercial value chains. Being able to interact with different banking APIs can be a time and cost consuming challenge. Even though the PSD2 requires European banks to provide APIs and despite the effort of market initiatives to provide common standard interfaces, there is still a multitude of divergent authorization schemes involved and a lot of space for implementation options. A bank can even decide not to join one of the known market initiatives and define it's own PSD2 compliant API. The purpose of this open banking gateway is to provide the community with a common and simple interface for accessing major Open Banking APIs.","title":"Tackle the Key Challenge for Third Party Providers of Payment Services"},{"location":"#introducing-the-fintech-as-a-major-role","text":"Being a regulator driven initiative, PSD2 mandates the regulation of TPPs. With this additional detail, the market is experiencing a distinction between regulated TPPs and non regulated FinTechs. This framework is therefore designed taking in consideration the existence of the category of payment service providers called FinTech that used APIs exposed by a regulated TPP to access payment services exposed by banks.","title":"Introducing the FinTech as a Major Role"},{"location":"#address-security-issues-associated-with-psu-access-to-multiple-interfaces","text":"In the Open Banking Context, a payment service user (PSU or banking account holder) might have to deal with up to 3 different user interface to initiate, authorize and get the requested banking service executed. There being redirected back and forth from one UserAgent (resp. device) to another. This intensive use of redirection in Open Banking bearing a lot of risk of impersonating the PSU, we set a goal of this Framework to dissect the complexity involved with those redirection processes and open forums for discussion of possible solutions and sample implementations. Following papers are the first attempt to capture the problem ( UserAgent Redirection , PSU Access Security Design ).","title":"Address Security Issues associated with PSU Access to Multiple Interfaces"},{"location":"#project-demo","text":"Demo deployment and guide","title":"Project Demo"},{"location":"#big-picture","text":"The following picture displays the overall architecture of this banking gateway:","title":"Big Picture"},{"location":"#security-concept","text":"The following picture displays the overall security concept of this banking gateway: Security concept has 2 kinds of flows: - authenticated (for consent sharing) - anonymous (for payments, but can be authenticated too). Here are detailed diagrams of each flow: - Authenticated security concept detailed flow - Anonymous security concept detailed flow","title":"Security concept"},{"location":"#technical-architecture","text":"The following picture displays the overall technical architecture concept of this banking gateway: Key components as shown on diagram : APIs: - Banking API and its implementation Banking API Impl - Consent API and its implementation Consent API Impl Facade: - Banking protocol facade Protocol: - Banking protocol API - XS2A compliant banking protocol Impl","title":"Technical architecture"},{"location":"#running-the-project-locally","text":"docker-compose-dev.yml - docker-compose file in the project root for Development (requires building docker images) docker-compose.yml - docker-compose file in the project root for Demo (Images will be pulled from DockerHub)","title":"Running the project locally"},{"location":"#information-for-developers","text":"Working with BPMN: As most protocols use BPMN, we have developed the plugin 'Flowable BPMN visualizer' that directly integrates into IntelliJ with code navigation, refactoring and other stuff for Flowable BPMN engine . It will make your work a lot easier as you don't need to leave IntelliJ to change diagram or to see what class is used at which step. Starting with project: How to start with project Populating database with bank data: How to fill database with bank data","title":"Information for developers:"},{"location":"#documentation","text":"Please take a look into our documentation to know more about:","title":"Documentation"},{"location":"#planned-and-released-versions","text":"Versioning, Release and Support policy Release notes Roadmap for next features development","title":"Planned and released versions"},{"location":"#architecture","text":"Dictionary Use Cases Banking Proto\u0441ol Design User Agent Redirection PSU Access Security Design JavaDoc","title":"Architecture"},{"location":"#third-parties-contribution","text":"This project is designed to enable contribution from different sources, as the open banking challenge will start with a magnitude of discrepancies in individual bank implementations, even for banks implementing a common standards.","title":"Third Parties Contribution"},{"location":"#how-to-contribute","text":"Getting started Contribution Guidelines","title":"How to contribute"},{"location":"#authors-contact","text":"Francis Pouatcha - Initial work - adorsys See also the list of contributors who participated in this project. For commercial support please contact adorsys Team .","title":"Authors &amp; Contact"},{"location":"#license","text":"This project is licensed under the Apache License version 2.0 - see the LICENSE file for details","title":"License"},{"location":"ContributionGuidelines/","text":"Development and contributing Internal development process Development is performed by 2-weeks sprints (We use kind of Scrum framework). We use Git flow for development. Leading branch is always develop . Each new feature/bugfix is done in its own branch. All features/bugs are documented in zenhub . After finishing branch and seeing that branch has successfully been build by travis a pull request to branch develop must be created in github . Each developer of the team with approval rights can have a look at pull request and do the review. If no review is done for more than 24 hours, the developer is allowed to merge the branch to develop branch. Of course build in travis must work after merge. The master branch is never touched. Never, except when release build is done. This is triggered by the project management. When release build is triggered the current develop is merged into master. For that master never ever must be updated manually. Definition of Ready The task is ready to be put into a sprint when all following conditions are met: * All dependencies are clear and the work to work with them are clarified * Use-case is defined in the task * Acceptance criteria are defined Definition of Done The Task could be accepted only when following requirements are met: * Code is reviewed (and approved) by another developer * API documentation in Swagger UI corresponds to acceptance criteria * At least one automated test for every Use-case exists nice to have Project documentation (Markdown files) contains the information how to run the demo of use case Javadocs for public methods are written (including parameter description). For REST interfaces Swagger-annotations are sufficient. Contributing Any person are free to join us by implementing some parts of code or fixing some bugs. For that separate branch has to be created. Technical conditions for the implementations Code styling If you are using Intellij IDEs, like we do, please consider importing our code-style settings. Further explanation in checkstyle Java Please use Optionals and corresponding streams instead of null-checks where possible We prefer using Mockito over EasyMock for unit-tests. We prefer SpringBoot autoconfiguration over manual Configuration where possible Adding new modules When adding new modules or changing other modules ensure you are adding them to last-module-codecoverage too. Open API 3.0 We use API First approach, so that API files are the first source of a contract. The code generated from opba-consent-rest-api/src/main/resources/static/consent_api.yml opba-banking-rest-api/src/main/resources/static/banking_api_ais.yml is generated to opba-consent-rest-api/target/generated-sources/open-api/src/main/java opba-banking-rest-api/target/generated-sources/open-api/src/main/java So the folders have to be made known to the IDE. Checkstyle The code uses backend.checkstyle.xml placed in the root of the project. To activate it with intellij install the CheckStyle-IDEA v5.34.0 Plugin and configure in Other Settings -> Checkstyle the version 8.19 and add the configuration file backend.checkstyle.xml . How to Release Release is being done using the release scripts ( (C) by Boris Skert ) located under scripts/release-scripts. For detailed info see README for release-scripts . Steps to make a release Release is made from local copy! Ensure that you have enough rights to push to master and develop branches $ git submodule update --init --remote $ scripts/release-scripts/release.sh <release-version> <next-develop-version> Example $ scripts/release-scripts/release.sh 1.0 1.1","title":"Contibution Guidelines"},{"location":"ContributionGuidelines/#development-and-contributing","text":"","title":"Development and contributing"},{"location":"ContributionGuidelines/#internal-development-process","text":"Development is performed by 2-weeks sprints (We use kind of Scrum framework). We use Git flow for development. Leading branch is always develop . Each new feature/bugfix is done in its own branch. All features/bugs are documented in zenhub . After finishing branch and seeing that branch has successfully been build by travis a pull request to branch develop must be created in github . Each developer of the team with approval rights can have a look at pull request and do the review. If no review is done for more than 24 hours, the developer is allowed to merge the branch to develop branch. Of course build in travis must work after merge. The master branch is never touched. Never, except when release build is done. This is triggered by the project management. When release build is triggered the current develop is merged into master. For that master never ever must be updated manually.","title":"Internal development process"},{"location":"ContributionGuidelines/#definition-of-ready","text":"The task is ready to be put into a sprint when all following conditions are met: * All dependencies are clear and the work to work with them are clarified * Use-case is defined in the task * Acceptance criteria are defined","title":"Definition of Ready"},{"location":"ContributionGuidelines/#definition-of-done","text":"The Task could be accepted only when following requirements are met: * Code is reviewed (and approved) by another developer * API documentation in Swagger UI corresponds to acceptance criteria * At least one automated test for every Use-case exists nice to have Project documentation (Markdown files) contains the information how to run the demo of use case Javadocs for public methods are written (including parameter description). For REST interfaces Swagger-annotations are sufficient.","title":"Definition of Done"},{"location":"ContributionGuidelines/#contributing","text":"Any person are free to join us by implementing some parts of code or fixing some bugs. For that separate branch has to be created.","title":"Contributing"},{"location":"ContributionGuidelines/#technical-conditions-for-the-implementations","text":"","title":"Technical conditions for the implementations"},{"location":"ContributionGuidelines/#code-styling","text":"If you are using Intellij IDEs, like we do, please consider importing our code-style settings. Further explanation in checkstyle","title":"Code styling"},{"location":"ContributionGuidelines/#java","text":"Please use Optionals and corresponding streams instead of null-checks where possible We prefer using Mockito over EasyMock for unit-tests. We prefer SpringBoot autoconfiguration over manual Configuration where possible","title":"Java"},{"location":"ContributionGuidelines/#adding-new-modules","text":"When adding new modules or changing other modules ensure you are adding them to last-module-codecoverage too.","title":"Adding new modules"},{"location":"ContributionGuidelines/#open-api-30","text":"We use API First approach, so that API files are the first source of a contract. The code generated from opba-consent-rest-api/src/main/resources/static/consent_api.yml opba-banking-rest-api/src/main/resources/static/banking_api_ais.yml is generated to opba-consent-rest-api/target/generated-sources/open-api/src/main/java opba-banking-rest-api/target/generated-sources/open-api/src/main/java So the folders have to be made known to the IDE.","title":"Open API 3.0"},{"location":"ContributionGuidelines/#checkstyle","text":"The code uses backend.checkstyle.xml placed in the root of the project. To activate it with intellij install the CheckStyle-IDEA v5.34.0 Plugin and configure in Other Settings -> Checkstyle the version 8.19 and add the configuration file backend.checkstyle.xml .","title":"Checkstyle"},{"location":"ContributionGuidelines/#how-to-release","text":"Release is being done using the release scripts ( (C) by Boris Skert ) located under scripts/release-scripts. For detailed info see README for release-scripts .","title":"How to Release"},{"location":"ContributionGuidelines/#steps-to-make-a-release","text":"Release is made from local copy! Ensure that you have enough rights to push to master and develop branches $ git submodule update --init --remote $ scripts/release-scripts/release.sh <release-version> <next-develop-version> Example $ scripts/release-scripts/release.sh 1.0 1.1","title":"Steps to make a release"},{"location":"demo_env/","text":"Introduction For the project demonstration, we provide you links and guideline of how to use our DEV environment. Please note that as it is DEV environment it might get unstable on occasion. Environment details Our DEV environment is configured to use Adorsys Dynamic Sandbox that closely imitates real ASPSP (Bank) with full set of XS2A-API functionality. Environment location and guide Location Environment is hosted at: https://obg-dev-fintechui.cloud.adorsys.de Demo video guide Guide transcript 1. Login to FinTech When you open https://obg-dev-fintechui.cloud.adorsys.de you will see FinTech example application login screen. It will allow you to use any not-registered user name with arbitrary 4 character password. I.e. type any random username and password '1234'. 2. Bank selection After you log in to the FinTech sample application, you will see bank selection screen there, you need to select your bank. Select 'adorsys xs2a'. 3. Asking for the account list On the next screen, you want to see your account and transaction list at the selected bank. Click on accounts button. 4. Redirection to OpenBanking server FinTech will ask you to redirect to OpenBanking server in order to provide consent to perform account and transaction listing. Click on the OK button. 5. Register in OpenBankingGateway Because users consent might be shared (if user allows) across multiple FinTechs', you will be prompted with login screen in OpenBankingGateway. Click on register button to create new user, you will be prompted with another form. Fill username with random username and password i.e. '1234'. Click on register button, you will be redirected back to login form. Fill the login form with credentials you used to register and login. 6. Consent scope selection After you have logged in to OpenBankingGateway, you will see Consent grant screen: Type 'anton.brueckner' to PSU ID field. Click Grant access. 7. Consent review You will see consent review screen: Click on confirm button. 8. Consent authorization On the next step you will enter either EMBEDDED consent authorization or REDIRECT consent authorization that will depend on current ASPSP configuration. All you need is to follow on-screen instructions and to fill forms with these values: - login: anton.brueckner - PIN/Password: 12345 - SCA/TAN challenge result: 123456 9. Redirect back to FinTech After you have granted the consent you will be redirected back to FinTech: Click on 'Back to Awesome FinTech' 10. Account list at FinTech UI You will be redirected back to FinTech and you have granted the consent to the FinTech to read your account list. Click on 'Accounts' button and you will see your accounts (anton.brueckner's accounts):","title":"Introduction"},{"location":"demo_env/#introduction","text":"For the project demonstration, we provide you links and guideline of how to use our DEV environment. Please note that as it is DEV environment it might get unstable on occasion.","title":"Introduction"},{"location":"demo_env/#environment-details","text":"Our DEV environment is configured to use Adorsys Dynamic Sandbox that closely imitates real ASPSP (Bank) with full set of XS2A-API functionality.","title":"Environment details"},{"location":"demo_env/#environment-location-and-guide","text":"","title":"Environment location and guide"},{"location":"demo_env/#location","text":"Environment is hosted at: https://obg-dev-fintechui.cloud.adorsys.de","title":"Location"},{"location":"demo_env/#demo-video-guide","text":"","title":"Demo video guide"},{"location":"demo_env/#guide-transcript","text":"","title":"Guide transcript"},{"location":"demo_env/#1-login-to-fintech","text":"When you open https://obg-dev-fintechui.cloud.adorsys.de you will see FinTech example application login screen. It will allow you to use any not-registered user name with arbitrary 4 character password. I.e. type any random username and password '1234'.","title":"1. Login to FinTech"},{"location":"demo_env/#2-bank-selection","text":"After you log in to the FinTech sample application, you will see bank selection screen there, you need to select your bank. Select 'adorsys xs2a'.","title":"2. Bank selection"},{"location":"demo_env/#3-asking-for-the-account-list","text":"On the next screen, you want to see your account and transaction list at the selected bank. Click on accounts button.","title":"3. Asking for the account list"},{"location":"demo_env/#4-redirection-to-openbanking-server","text":"FinTech will ask you to redirect to OpenBanking server in order to provide consent to perform account and transaction listing. Click on the OK button.","title":"4. Redirection to OpenBanking server"},{"location":"demo_env/#5-register-in-openbankinggateway","text":"Because users consent might be shared (if user allows) across multiple FinTechs', you will be prompted with login screen in OpenBankingGateway. Click on register button to create new user, you will be prompted with another form. Fill username with random username and password i.e. '1234'. Click on register button, you will be redirected back to login form. Fill the login form with credentials you used to register and login.","title":"5. Register in OpenBankingGateway"},{"location":"demo_env/#6-consent-scope-selection","text":"After you have logged in to OpenBankingGateway, you will see Consent grant screen: Type 'anton.brueckner' to PSU ID field. Click Grant access.","title":"6. Consent scope selection"},{"location":"demo_env/#7-consent-review","text":"You will see consent review screen: Click on confirm button.","title":"7. Consent review"},{"location":"demo_env/#8-consent-authorization","text":"On the next step you will enter either EMBEDDED consent authorization or REDIRECT consent authorization that will depend on current ASPSP configuration. All you need is to follow on-screen instructions and to fill forms with these values: - login: anton.brueckner - PIN/Password: 12345 - SCA/TAN challenge result: 123456","title":"8. Consent authorization"},{"location":"demo_env/#9-redirect-back-to-fintech","text":"After you have granted the consent you will be redirected back to FinTech: Click on 'Back to Awesome FinTech'","title":"9. Redirect back to FinTech"},{"location":"demo_env/#10-account-list-at-fintech-ui","text":"You will be redirected back to FinTech and you have granted the consent to the FinTech to read your account list. Click on 'Accounts' button and you will see your accounts (anton.brueckner's accounts):","title":"10. Account list at FinTech UI"},{"location":"getting_started/","text":"How to start the project Compile everything with make all . Alternatively compile Java code with mvn clean package and frontend with npm build at fintech-examples/fintech-ui Start frontends with npm serve from fintech-examples/fintech-ui Start backends with mvn spring-boot:run from opba-embedded-starter","title":"Getting started"},{"location":"getting_started/#how-to-start-the-project","text":"Compile everything with make all . Alternatively compile Java code with mvn clean package and frontend with npm build at fintech-examples/fintech-ui Start frontends with npm serve from fintech-examples/fintech-ui Start backends with mvn spring-boot:run from opba-embedded-starter","title":"How to start the project"},{"location":"initial_requirements/","text":"Initial Requirements Still in a draft state. We are working on the process of aligning documentation and code. Till that is done, we will be documenting using the gh-pages branch. What can you find here:","title":"Initial requirements"},{"location":"initial_requirements/#initial-requirements","text":"Still in a draft state. We are working on the process of aligning documentation and code. Till that is done, we will be documenting using the gh-pages branch. What can you find here:","title":"Initial Requirements"},{"location":"releasenotes/","text":"Release Notes release 0.0.5 Login Page creation for the Demo Frontend Change Test data with productive data for the TppBankSearchApi Update the general project's documentation Getting Started documentation Definition of the FinTechApi, BankingApi and ConsentAuthorisationApi Integration of Bank search API and FintechUI release 0.0.4 release 0.0.3 Write Sequence diagram uses cases based Validation of flowable BPMN engine (great job!) Backend Proof of Concept Implementation of TppBankSearchApi Create CI/CD code quality checks Write Contributions guidelines|","title":"Release notes"},{"location":"releasenotes/#release-notes","text":"","title":"Release Notes"},{"location":"releasenotes/#release-005","text":"Login Page creation for the Demo Frontend Change Test data with productive data for the TppBankSearchApi Update the general project's documentation Getting Started documentation Definition of the FinTechApi, BankingApi and ConsentAuthorisationApi Integration of Bank search API and FintechUI","title":"release 0.0.5"},{"location":"releasenotes/#release-004","text":"","title":"release 0.0.4"},{"location":"releasenotes/#release-003","text":"Write Sequence diagram uses cases based Validation of flowable BPMN engine (great job!) Backend Proof of Concept Implementation of TppBankSearchApi Create CI/CD code quality checks Write Contributions guidelines|","title":"release 0.0.3"},{"location":"roadmap/","text":"Roadmap Our project started on November 1st 2019 and the Open Banking Gateway team offers development with two branches: Develop branch : This is the branch from which a release is built and used to collect all the other branches. Master branch : generally matches the last released stable version. This project is planned until the end of 2020 and our current timetable plans MVP1 for April 2020, by which time the following targets should be achieved: * Demo Frontend used to test the Open Banking Gateway * Integration of German banks with Redirect and Embedded Approaches * TppBankSearchApi providing only German banks * TppBankingApi providing the following banking endpoints: * Get transaction information * Get list of reachable accounts * Get account details of a list of accessible accounts * Get balances for a given account and * Initiation of single payment release date version 20.12.2019 0.0.3 Sequence diagram describing use cases Validation of flowable BPMN engine Backend Proof of Concept Implementation of TppBankSearchApi Create CI/CD and code quality checks Write Contributions guidelines 16.01.2020 0.0.4 Login Page creation for the Demo Frontend Change Test data with productive data for the TppBankSearchApi Update the general project's documentation Getting Started documentation Definition of the FinTechApi, BankingApi and ConsentAuthorisationApi Integration of Bank search API and FintechUI 29.01.2020 0.0.5 Move the implemented TppBankSearchApi to a separate module Make a Backend for the login to the FinTechUi Implementation of the Login Page Dummy Implementation of the BankingApi list of account Dummy Implementation of the list of account of the FinTechApi Create relation between BankId and Service offered Create Banking Protocol Facade Implementation of the Banking Protocol for the dynamic Sandbox Create the database migration module 16.03.2020 0.0.6 Bank Search (Login Fintech, BankSearch, BankSelect, BankServices) Get List of Accounts redirect approach with XS2A Sandbox 30.03.2020 0.0.7 Get List of Transaction redirect approach with XS2A Sandbox Get List of Accounts embedded approach with XS2A Sandbox Get List of Transactions embedded approach with XS2A Sandbox 14.04.2020 0.0.8 Implementation of the Security Concepts 27.04.2020 0.0.9 Get List of Account redirect approach with productive Bank (Deutsche Bank) Get List of Accounts embedded approach with productive Bank (Sparkasse) Following features are planned for MVP1 (01.11.2019 - 30.04.2020) * Bank Search (Login Fintech, BankSearch, BankSelect, BankServices) * List of Accounts Redirect with Sandbox * List of Transactions Redirect with Sandbox * List of Accounts Embedded with Sandbox * List of Transactions Embedded with Sandbox * Security Concepts * List of Account Redirect with Bank * List of Account Embedded with Bank","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"Our project started on November 1st 2019 and the Open Banking Gateway team offers development with two branches: Develop branch : This is the branch from which a release is built and used to collect all the other branches. Master branch : generally matches the last released stable version. This project is planned until the end of 2020 and our current timetable plans MVP1 for April 2020, by which time the following targets should be achieved: * Demo Frontend used to test the Open Banking Gateway * Integration of German banks with Redirect and Embedded Approaches * TppBankSearchApi providing only German banks * TppBankingApi providing the following banking endpoints: * Get transaction information * Get list of reachable accounts * Get account details of a list of accessible accounts * Get balances for a given account and * Initiation of single payment release date version 20.12.2019 0.0.3 Sequence diagram describing use cases Validation of flowable BPMN engine Backend Proof of Concept Implementation of TppBankSearchApi Create CI/CD and code quality checks Write Contributions guidelines 16.01.2020 0.0.4 Login Page creation for the Demo Frontend Change Test data with productive data for the TppBankSearchApi Update the general project's documentation Getting Started documentation Definition of the FinTechApi, BankingApi and ConsentAuthorisationApi Integration of Bank search API and FintechUI 29.01.2020 0.0.5 Move the implemented TppBankSearchApi to a separate module Make a Backend for the login to the FinTechUi Implementation of the Login Page Dummy Implementation of the BankingApi list of account Dummy Implementation of the list of account of the FinTechApi Create relation between BankId and Service offered Create Banking Protocol Facade Implementation of the Banking Protocol for the dynamic Sandbox Create the database migration module 16.03.2020 0.0.6 Bank Search (Login Fintech, BankSearch, BankSelect, BankServices) Get List of Accounts redirect approach with XS2A Sandbox 30.03.2020 0.0.7 Get List of Transaction redirect approach with XS2A Sandbox Get List of Accounts embedded approach with XS2A Sandbox Get List of Transactions embedded approach with XS2A Sandbox 14.04.2020 0.0.8 Implementation of the Security Concepts 27.04.2020 0.0.9 Get List of Account redirect approach with productive Bank (Deutsche Bank) Get List of Accounts embedded approach with productive Bank (Sparkasse) Following features are planned for MVP1 (01.11.2019 - 30.04.2020) * Bank Search (Login Fintech, BankSearch, BankSelect, BankServices) * List of Accounts Redirect with Sandbox * List of Transactions Redirect with Sandbox * List of Accounts Embedded with Sandbox * List of Transactions Embedded with Sandbox * Security Concepts * List of Account Redirect with Bank * List of Account Embedded with Bank","title":"Roadmap"},{"location":"version_policy/","text":"Versioning, Release and Support policy In general the OpenBanking Gateway Team follows SemVer for versioning. This means our versions follow the model A.B.C, where: A - is the major version, pointing out mainline. B - is the minor version, pointing out the next release in the mainline. Minimum 2 versions backward compatibility is guaranteed for stable mainlines. C - is the hotfix version, used to deliver patches between releases when needed. If omitted, version 4.5 will be considered equal to 4.5.0. We support one stable and one development version at any moment. To keep it simple: We use even major version to mark stable support mainlines (2.x, 4.x, 6.x etc) We use odd major version to mark development mainlines (1.x, 3.x, 5.x etc) Normally new development versions are released every two weeks, however this is not a strict rule, rather our willingness. Backward compatibility For stable mainlines we provide backward compatibility of APIs and Database schema. Although for stable versions backward compatibility is high priority and we try our best to keep it as much as possible, we can guarantee backward compatibility only for two versions before. I.e. if you get version 4.25, it will keep backward compatibility with 4.24 and 4.23, but some changes may appear between APIs of version 4.25 with version 4.22. The same is valid for the database schema. If you need extended support, please contact adorsys Team . Stable versions Stable versions are recommended for production usage. Normally they have support period of time at least 6 months. If you need additional support, please contact adorsys Team . There is no stable version released as for now.","title":"Version policy"},{"location":"version_policy/#versioning-release-and-support-policy","text":"In general the OpenBanking Gateway Team follows SemVer for versioning. This means our versions follow the model A.B.C, where: A - is the major version, pointing out mainline. B - is the minor version, pointing out the next release in the mainline. Minimum 2 versions backward compatibility is guaranteed for stable mainlines. C - is the hotfix version, used to deliver patches between releases when needed. If omitted, version 4.5 will be considered equal to 4.5.0. We support one stable and one development version at any moment. To keep it simple: We use even major version to mark stable support mainlines (2.x, 4.x, 6.x etc) We use odd major version to mark development mainlines (1.x, 3.x, 5.x etc) Normally new development versions are released every two weeks, however this is not a strict rule, rather our willingness.","title":"Versioning, Release and Support policy"},{"location":"version_policy/#backward-compatibility","text":"For stable mainlines we provide backward compatibility of APIs and Database schema. Although for stable versions backward compatibility is high priority and we try our best to keep it as much as possible, we can guarantee backward compatibility only for two versions before. I.e. if you get version 4.25, it will keep backward compatibility with 4.24 and 4.23, but some changes may appear between APIs of version 4.25 with version 4.22. The same is valid for the database schema. If you need extended support, please contact adorsys Team .","title":"Backward compatibility"},{"location":"version_policy/#stable-versions","text":"Stable versions are recommended for production usage. Normally they have support period of time at least 6 months. If you need additional support, please contact adorsys Team . There is no stable version released as for now.","title":"Stable versions"},{"location":"architecture/1-loginWithFinTech/","text":"User Login Diagram Description Login-001, -002, -003 FinTechUI.loadFinTechApplication & enterLoginData FinTechUI displays the LoginUI to the PSU. PSU enters username and password and initiates the login request. In a productive use case, the login request will be handled by an identity provider. Login-004, -005 FinTechApi.login The PSU initiates a session with the FinTech providing his username and password as known to the FinTechApi. Username and password are provided in a LoginRequest object. Upon successful login, the FinTechApi will return a response of type 200_UserProfile . Note that the response object contains both a SessionCookie and a corresponding XSRF-TOKEN Login-006 FinTechUI.parseAndStoreXsrfToken The xsrfToken returned by the server must be parsed and stored by the FinTechUI for association with each subsequent request. The FinTechUI must parse and store this xsrfToken, so that it is accessible whenever the application is reloaded. Login-007 FinTechUI.displayBankSearchScreen Upon successful login, the FinTechUi displays the bank search screen to the PSU.","title":"Login with FinTech Application"},{"location":"architecture/1-loginWithFinTech/#user-login","text":"","title":"User Login"},{"location":"architecture/1-loginWithFinTech/#diagram","text":"","title":"Diagram"},{"location":"architecture/1-loginWithFinTech/#description","text":"","title":"Description"},{"location":"architecture/1-loginWithFinTech/#login-001-002-003-fintechuiloadfintechapplication-enterlogindata","text":"FinTechUI displays the LoginUI to the PSU. PSU enters username and password and initiates the login request. In a productive use case, the login request will be handled by an identity provider.","title":"Login-001, -002, -003 FinTechUI.loadFinTechApplication &amp; enterLoginData"},{"location":"architecture/1-loginWithFinTech/#login-004-005-fintechapilogin","text":"The PSU initiates a session with the FinTech providing his username and password as known to the FinTechApi. Username and password are provided in a LoginRequest object. Upon successful login, the FinTechApi will return a response of type 200_UserProfile . Note that the response object contains both a SessionCookie and a corresponding XSRF-TOKEN","title":"Login-004, -005 FinTechApi.login"},{"location":"architecture/1-loginWithFinTech/#login-006-fintechuiparseandstorexsrftoken","text":"The xsrfToken returned by the server must be parsed and stored by the FinTechUI for association with each subsequent request. The FinTechUI must parse and store this xsrfToken, so that it is accessible whenever the application is reloaded.","title":"Login-006 FinTechUI.parseAndStoreXsrfToken"},{"location":"architecture/1-loginWithFinTech/#login-007-fintechuidisplaybanksearchscreen","text":"Upon successful login, the FinTechUi displays the bank search screen to the PSU.","title":"Login-007 FinTechUI.displayBankSearchScreen"},{"location":"architecture/2-searchBank/","text":"PSU Searches Bank By Keyword Definition Describes the bank search functionality in a FinTech Application. Generally bank search is provided to prevent PSU from manually entering complicated bank identifiers. This bank search API allows for incremental keyword based search. Implementation Approaches We will distinguish between remote and local incremental search. Remote Incremental Search The remote incremental search is implemented on the server side. A rest endpoint receives a keyword and return a list of matching search entries. Use Case Steps Use cases for this API: 1. PSU loads FinTechSearchScreen 2. FinTechUI displays a search screen to the PSU 3. PSU enters any keyword in the search input field 4. FinTechUI forward request to FinTechAPI 5. FinTechAPI forward request to TppBankSearchApi 6. TppBankSearchApi returns a list of matching BankDescriptors to FinTechAPI 7. FinTechAPI returns a list of matching BankDescriptors to FinTechBankSearchUI 8. UI displays list of found bank descriptors to PSU Step 4. through 8. is repeated as long as PSU modifies keywords (by adding or removing characters) RemoteSearch-001, -002 FinTechUI.loadFinTechSeachScreen, displaySearchScreen RemoteSearch-003 FinTechUI.enterSearchString RemoteSearch-004 FinTechApi.bankSearch The FinTechUI sends a get request to the FinTechApi. Request contains * keyword (searchInput): The bank search input string * start (searchStartIndex): The index of the first result * max (searchMaxResult): the max number of entries to return with the response. * sessionState: provided as a path param. Used to read the FinTechLoginSessionCookie. * FinTechLoginSessionCookie: provided in the Cookie header. Used to identify the PSU. RemoteSearch-005, -006 TppBankSearchApi.bankSearch The FinTechApi sends a get request to the TppBankSearchApi. Request contains * keyword (searchInput): The bank search input string * start (searchStartIndex): The index of the first result * max (searchMaxResult): the max number of entries to return with the response. TppBankSearchApi returns a search result with following information. * List : found entries. * searchInput: The bank search input string (might have been normalized in the backend). * searchStartIndex: The index of the first result * searchMaxResult: The max number of entries to return with the response. * searchTotalResult: The total count of entities found for the given search input. RemoteSearch-007 FinTechApi return 200_BankSearchResult Result returned to FinTechUI contains same information as in RemoteSearch-005 and addition session management information like: * sessionState: provided in the response body. Used read the FinTechLoginSessionCookie. * FinTechLoginSessionCookie: provided in the Set-Cookie header. RemoteSearch-007 FinTechUI.displaySearchResult Finally, the FinTechUI display's the bank search result to the PSU. Local Incremental Search Local incremental search generally provides a way of reducing round trip to servers. So there is no local incremental search endpoint, but an endpoint to download the list of all BankProfiles. The client is then responsible for the indexing and the implementation of the search logic. For the purpose of keeping the client code simple, interface will also provide the possibility of downloading a standard lucene index file, as many platform provide login provide processing of lucene indexes. This approach will prevent each client from perfoming the expensive lucene indexing. The following diagram describes additional steps performed in the local incremental search. Use Case Steps Use cases for this API: 1. PSU loads FinTechSearchScreen 2. FinTechUI requests the BankSearchIndex from FinTechApi 3. FinTechApi requests the BankSearchIndex from TppBankSearchApi 4. TppBankSearchApi return BankSearchIndex to FinTechApi 5. FinTechApi return BankSearchIndex to FinTechUI 6. FinTechUI displays a search screen to the PSU 7. PSU enters any keyword in the search input field 8. FinTechUI call the search routine of the embedded LocalSearch 9. LocalSearch uses the keyword to retrieve the list of matching entries 10. LocalSearch returns a list of matching BankDescriptors to FinTechBankSearchUI 11. UI displays list of found bank descriptors to PSU Step 8. through 11. is repeated as long as PSU modifies keywords (by adding or removing characters) Like this diagram shows, local bank search does not send request to the network. LocalSearch-001 FinTechUI.loadFinTechSeachScreen PSU loads the FinTechSearchString of the FinTechUI. LocalSearch-101, -103 FinTechApi.bankSearch The FinTechUI sends a get request to the FinTechApi. If the List is not yet loaded by the FinTechUI, the FinTechUI issues a bankSearch request to the FinTechApi. A keyword passed as query parameter allows the backend to reduce the initial extent of records included in the index. keyword (searchInput): The bank search input string. Must be used to reduce the extent of records to be included in the local search. E.g.: c=DE could limit the search to bank in Germany. start (searchStartIndex): The index of the first result. The start will be set to 0 to get all records. max (searchMaxResult): the max number of entries to return with the response. Set this number to -1 to receive all applicable records from the server. sessionState: provided as a path parameter. Used to read the FinTechLoginSessionCookie. FinTechLoginSessionCookie: provided in the Cookie header. Used to identify the PSU. TppBankSearchApi returns a search result with following information. * List : found entries. * searchInput: The bank search input string (might have been normalized in the backend). * searchStartIndex: The index of the first result * searchMaxResult: The max number of entries to return with the response. * searchTotalResult: The total count of entities found for the given search input. LocalSearch-102, -103 TppBankSearchApi.bankSearch The FinTechApi sends a get request to the TppBankSearchApi. Request contains * keyword (searchInput): The bank search input string * start (searchStartIndex): The index of the first result * max (searchMaxResult): the max number of entries to return with the response. TppBankSearchApi returns a search result with following information. * List : found entries. * searchInput: The bank search input string (might have been normalized in the backend). * searchStartIndex: The index of the first result * searchMaxResult: The max number of entries to return with the response. * searchTotalResult: The total count of entities found for the given search input. LocalSearch-104 FinTechApi return 200_BankSearchResult Result returned to FinTechUI contains same information as in LocalSearch-103 and addition session management information like: * sessionState: provided in the response body. Used read the FinTechLoginSessionCookie. * FinTechLoginSessionCookie: provided in the Set-Cookie header. LocalSearch-105 displaySearchScreen LocalSearch-106 .. 110 enterKeyword, LocalSearch.search As the PSU enters search keywords, the FinTechUI issues a search request to the LocalSearch that performs the search operation locally and returns corresponding result that is displayed to the PSU on the go. New Idioms Discriminator The searchInput object passed to FinTechApi in this case is called discriminator and is used to reduce the extent of records to be included in the local search. E.g.: c=DE could limit the search to bank in Germany. If for example the TPP does not support some banks, he can include that information in the searchInput-String. LocalSearch This is the UI-Komponent that operates (like lucene) on a local search index in the UI-Application. The technology used to implement this search is specific to the UI technology. JavaScript based technologies might use tools like: elasticlunr Caching List The List return for the purpose of a local search can be cached by the FinTechApi to reduce quantity of request issued to the TppBankSearchApi","title":"Search bank"},{"location":"architecture/2-searchBank/#psu-searches-bank-by-keyword","text":"","title":"PSU Searches Bank By Keyword"},{"location":"architecture/2-searchBank/#definition","text":"Describes the bank search functionality in a FinTech Application. Generally bank search is provided to prevent PSU from manually entering complicated bank identifiers. This bank search API allows for incremental keyword based search.","title":"Definition"},{"location":"architecture/2-searchBank/#implementation-approaches","text":"We will distinguish between remote and local incremental search.","title":"Implementation Approaches"},{"location":"architecture/2-searchBank/#remote-incremental-search","text":"The remote incremental search is implemented on the server side. A rest endpoint receives a keyword and return a list of matching search entries.","title":"Remote Incremental Search"},{"location":"architecture/2-searchBank/#use-case-steps","text":"Use cases for this API: 1. PSU loads FinTechSearchScreen 2. FinTechUI displays a search screen to the PSU 3. PSU enters any keyword in the search input field 4. FinTechUI forward request to FinTechAPI 5. FinTechAPI forward request to TppBankSearchApi 6. TppBankSearchApi returns a list of matching BankDescriptors to FinTechAPI 7. FinTechAPI returns a list of matching BankDescriptors to FinTechBankSearchUI 8. UI displays list of found bank descriptors to PSU Step 4. through 8. is repeated as long as PSU modifies keywords (by adding or removing characters)","title":"Use Case Steps"},{"location":"architecture/2-searchBank/#remotesearch-001-002-fintechuiloadfintechseachscreen-displaysearchscreen","text":"","title":"RemoteSearch-001, -002 FinTechUI.loadFinTechSeachScreen, displaySearchScreen"},{"location":"architecture/2-searchBank/#remotesearch-003-fintechuientersearchstring","text":"","title":"RemoteSearch-003 FinTechUI.enterSearchString"},{"location":"architecture/2-searchBank/#remotesearch-004-fintechapibanksearch","text":"The FinTechUI sends a get request to the FinTechApi. Request contains * keyword (searchInput): The bank search input string * start (searchStartIndex): The index of the first result * max (searchMaxResult): the max number of entries to return with the response. * sessionState: provided as a path param. Used to read the FinTechLoginSessionCookie. * FinTechLoginSessionCookie: provided in the Cookie header. Used to identify the PSU.","title":"RemoteSearch-004 FinTechApi.bankSearch"},{"location":"architecture/2-searchBank/#remotesearch-005-006-tppbanksearchapibanksearch","text":"The FinTechApi sends a get request to the TppBankSearchApi. Request contains * keyword (searchInput): The bank search input string * start (searchStartIndex): The index of the first result * max (searchMaxResult): the max number of entries to return with the response. TppBankSearchApi returns a search result with following information. * List : found entries. * searchInput: The bank search input string (might have been normalized in the backend). * searchStartIndex: The index of the first result * searchMaxResult: The max number of entries to return with the response. * searchTotalResult: The total count of entities found for the given search input.","title":"RemoteSearch-005, -006 TppBankSearchApi.bankSearch"},{"location":"architecture/2-searchBank/#remotesearch-007-fintechapi-return-200_banksearchresult","text":"Result returned to FinTechUI contains same information as in RemoteSearch-005 and addition session management information like: * sessionState: provided in the response body. Used read the FinTechLoginSessionCookie. * FinTechLoginSessionCookie: provided in the Set-Cookie header.","title":"RemoteSearch-007 FinTechApi return 200_BankSearchResult"},{"location":"architecture/2-searchBank/#remotesearch-007-fintechuidisplaysearchresult","text":"Finally, the FinTechUI display's the bank search result to the PSU.","title":"RemoteSearch-007 FinTechUI.displaySearchResult"},{"location":"architecture/2-searchBank/#local-incremental-search","text":"Local incremental search generally provides a way of reducing round trip to servers. So there is no local incremental search endpoint, but an endpoint to download the list of all BankProfiles. The client is then responsible for the indexing and the implementation of the search logic. For the purpose of keeping the client code simple, interface will also provide the possibility of downloading a standard lucene index file, as many platform provide login provide processing of lucene indexes. This approach will prevent each client from perfoming the expensive lucene indexing. The following diagram describes additional steps performed in the local incremental search.","title":"Local Incremental Search"},{"location":"architecture/2-searchBank/#use-case-steps_1","text":"Use cases for this API: 1. PSU loads FinTechSearchScreen 2. FinTechUI requests the BankSearchIndex from FinTechApi 3. FinTechApi requests the BankSearchIndex from TppBankSearchApi 4. TppBankSearchApi return BankSearchIndex to FinTechApi 5. FinTechApi return BankSearchIndex to FinTechUI 6. FinTechUI displays a search screen to the PSU 7. PSU enters any keyword in the search input field 8. FinTechUI call the search routine of the embedded LocalSearch 9. LocalSearch uses the keyword to retrieve the list of matching entries 10. LocalSearch returns a list of matching BankDescriptors to FinTechBankSearchUI 11. UI displays list of found bank descriptors to PSU Step 8. through 11. is repeated as long as PSU modifies keywords (by adding or removing characters) Like this diagram shows, local bank search does not send request to the network.","title":"Use Case Steps"},{"location":"architecture/2-searchBank/#localsearch-001-fintechuiloadfintechseachscreen","text":"PSU loads the FinTechSearchString of the FinTechUI.","title":"LocalSearch-001 FinTechUI.loadFinTechSeachScreen"},{"location":"architecture/2-searchBank/#localsearch-101-103-fintechapibanksearch","text":"The FinTechUI sends a get request to the FinTechApi. If the List is not yet loaded by the FinTechUI, the FinTechUI issues a bankSearch request to the FinTechApi. A keyword passed as query parameter allows the backend to reduce the initial extent of records included in the index. keyword (searchInput): The bank search input string. Must be used to reduce the extent of records to be included in the local search. E.g.: c=DE could limit the search to bank in Germany. start (searchStartIndex): The index of the first result. The start will be set to 0 to get all records. max (searchMaxResult): the max number of entries to return with the response. Set this number to -1 to receive all applicable records from the server. sessionState: provided as a path parameter. Used to read the FinTechLoginSessionCookie. FinTechLoginSessionCookie: provided in the Cookie header. Used to identify the PSU. TppBankSearchApi returns a search result with following information. * List : found entries. * searchInput: The bank search input string (might have been normalized in the backend). * searchStartIndex: The index of the first result * searchMaxResult: The max number of entries to return with the response. * searchTotalResult: The total count of entities found for the given search input.","title":"LocalSearch-101, -103 FinTechApi.bankSearch"},{"location":"architecture/2-searchBank/#localsearch-102-103-tppbanksearchapibanksearch","text":"The FinTechApi sends a get request to the TppBankSearchApi. Request contains * keyword (searchInput): The bank search input string * start (searchStartIndex): The index of the first result * max (searchMaxResult): the max number of entries to return with the response. TppBankSearchApi returns a search result with following information. * List : found entries. * searchInput: The bank search input string (might have been normalized in the backend). * searchStartIndex: The index of the first result * searchMaxResult: The max number of entries to return with the response. * searchTotalResult: The total count of entities found for the given search input.","title":"LocalSearch-102, -103 TppBankSearchApi.bankSearch"},{"location":"architecture/2-searchBank/#localsearch-104-fintechapi-return-200_banksearchresult","text":"Result returned to FinTechUI contains same information as in LocalSearch-103 and addition session management information like: * sessionState: provided in the response body. Used read the FinTechLoginSessionCookie. * FinTechLoginSessionCookie: provided in the Set-Cookie header.","title":"LocalSearch-104 FinTechApi return 200_BankSearchResult"},{"location":"architecture/2-searchBank/#localsearch-105-displaysearchscreen","text":"","title":"LocalSearch-105 displaySearchScreen"},{"location":"architecture/2-searchBank/#localsearch-106-110-enterkeyword-localsearchsearch","text":"As the PSU enters search keywords, the FinTechUI issues a search request to the LocalSearch that performs the search operation locally and returns corresponding result that is displayed to the PSU on the go.","title":"LocalSearch-106 .. 110 enterKeyword, LocalSearch.search"},{"location":"architecture/2-searchBank/#new-idioms","text":"","title":"New Idioms"},{"location":"architecture/2-searchBank/#discriminator","text":"The searchInput object passed to FinTechApi in this case is called discriminator and is used to reduce the extent of records to be included in the local search. E.g.: c=DE could limit the search to bank in Germany. If for example the TPP does not support some banks, he can include that information in the searchInput-String.","title":"Discriminator"},{"location":"architecture/2-searchBank/#localsearch","text":"This is the UI-Komponent that operates (like lucene) on a local search index in the UI-Application. The technology used to implement this search is specific to the UI technology. JavaScript based technologies might use tools like: elasticlunr","title":"LocalSearch"},{"location":"architecture/2-searchBank/#caching-list","text":"The List return for the purpose of a local search can be cached by the FinTechApi to reduce quantity of request issued to the TppBankSearchApi","title":"Caching List"},{"location":"architecture/3-selectBank/","text":"Select Bank General terms defined in the dictionary Definition The bank selection allows to download the BankProfile of a bank and cache it in the consent session for reuse while processing the PSU request. It can also be used to display bank details to the PSU at selection. Diagram Use Case Steps Use cases for this API: SelBnk-001 FinTechUI.selectBank PSU selects a bank from the list of banks displayed by the FinTechUI SelBnk-002 FinTechApi.loadBankProfile FinTechUI sends a load loadBankProfile request to FinTechAPI passing the bankId SelBnk-003 TppBankSearchApi.loadBankProfile FinTechAPI sends a load loadBankProfile request to TppBankSearchApi passing the bankId SelBnk-004 & 005 Return 200_BankProfile TppBankSearchApi returns the BankProfine object matching the given bankId. SelBnk-005 FinTechUI.displayBankProfile The displayed bank profile also displays banking api services offered by the selected bank.","title":"Select bank"},{"location":"architecture/3-selectBank/#select-bank","text":"General terms defined in the dictionary","title":"Select Bank"},{"location":"architecture/3-selectBank/#definition","text":"The bank selection allows to download the BankProfile of a bank and cache it in the consent session for reuse while processing the PSU request. It can also be used to display bank details to the PSU at selection.","title":"Definition"},{"location":"architecture/3-selectBank/#diagram","text":"","title":"Diagram"},{"location":"architecture/3-selectBank/#use-case-steps","text":"Use cases for this API:","title":"Use Case Steps"},{"location":"architecture/3-selectBank/#selbnk-001-fintechuiselectbank","text":"PSU selects a bank from the list of banks displayed by the FinTechUI","title":"SelBnk-001 FinTechUI.selectBank"},{"location":"architecture/3-selectBank/#selbnk-002-fintechapiloadbankprofile","text":"FinTechUI sends a load loadBankProfile request to FinTechAPI passing the bankId","title":"SelBnk-002 FinTechApi.loadBankProfile"},{"location":"architecture/3-selectBank/#selbnk-003-tppbanksearchapiloadbankprofile","text":"FinTechAPI sends a load loadBankProfile request to TppBankSearchApi passing the bankId","title":"SelBnk-003 TppBankSearchApi.loadBankProfile"},{"location":"architecture/3-selectBank/#selbnk-004-005-return-200_bankprofile","text":"TppBankSearchApi returns the BankProfine object matching the given bankId.","title":"SelBnk-004 &amp; 005 Return 200_BankProfile"},{"location":"architecture/3-selectBank/#selbnk-005-fintechuidisplaybankprofile","text":"The displayed bank profile also displays banking api services offered by the selected bank.","title":"SelBnk-005 FinTechUI.displayBankProfile"},{"location":"architecture/4a-aisListOfAccounts/","text":"List Of Accounts General terms defined in the dictionary Definition Requests the list of bank accounts associated with this PSU's online banking account at the target ASPSP. If there is any reference to an existing account information consent (AisConsent) stored in the database of the TPP, the TPP will use this consent reference to forward the service request to the OpenBanking interface of the ASPSP. If there is no such reference in the database of the TPP, the TPP will respond the FinTech to redirect the PSU to the ConsentAuthorizationApi of the TPP. Identifying the PSU In order to uniquely identify the requesting PSU, the TPP uses a unique reference made out of: * the fintechId : the unique identifier of this FinTech in the realm of the TPP. This parameter is read from the FinTechContext transported as jwt-Token in the authorization header of each FinTech request to the TPP. * the psu-id@fintech : the unique identifier of the PSU in the realm of the FinTech. This parameter is transported in the HttpHeader named: Fintech-User-ID * PsuAuthData : this is an object opaque to the FinTechAPI and contains additional context information provided by the tpp and to be stored by the FinTechApi and provided if available through the corresponding header field. Mapping PSU Requests to Consent The complexity of mapping a PSU service request to an existing consent is kept in the database of the TPP. The only responsibility of a FinTech is to: * provide a unique psu-id@fintech per PSU * add the the PsuAuthData to the request if available * to associate the psu-id@fintech with a newly returned PsuAuthData and store this in the database of the FinTechAPI. Diagram Use Cases LoA-010 FinTechUI.displayBankServices The result of a bank selection is that the FinTechUI displays the BankProfile to the PSU. The bank profile contains the list of services offered by the selected bank. For account information, this list generally contains only the first service \"listOfAccounts\" as all other account information services rely on the target account selected and identified by account-id. LoA-020 : FinTechUI.selectService(listOfAccounts) Once selected by the PSU, the FinTechUI forwards the service selected to the FinTechApi. In this case \"listOfAccounts\". The selection might be accompanied with some service specifications. For listOfAccounts, the option withBalance can be added to indicate that the balance has to be returned as well. LoA-021 : FinTechUI.readRedirectUrls(Fintech-Redirect-URL-OK,Fintech-Redirect-URL-NOK) Prepare the redirect urls associated with this request. These are URL used to start the UI from the ConsentAuthorizeAPI. LoA-030 : FinTechApi.listOfAccounts See FinTechApi.listOfAccounts LoA-031 : FinTechApi.checkAuthorization Call specification: : checkAuthorization(SessionCookie,X-XSRF-TOKEN):psu-id@fintech Before proceeding with the request, the FinTechApi must validate the request for it authenticity and extract a unique identifier of the PSU in the world of the FinTech (psu-id@fintech). This validation also include the matching of the used cookie against the provided XSRF-Token. LoA-032 : FinTechApi.userAgentContext Parses the HTTP request and extract information associated with the user agent (see UserAgentContext ). The UserAgentContext describes details associated with the user agent of the PSU. Generally not visible in the API as they are automatically provided by the user agent. The purpose is to transfer context specific information on both current Request and PsuUserAgent. Those information might later be required by the ASPSP like. Below is a non exhaustive list of UserAgent specific context information: * IP-Address, * IP-Port, * Accept, * Accept-Charset, * Accept-Encoding, * Accept-Language, * Device-ID, * User-Agent, * PSU-Geo-Location, * Http-Method. LoA-033 : FinTechApi.loadServiceSession (Deprecated) LoA-034 : FinTechApi.loadPsuAuthData Load PsuUserData associated with psu-id@fintech. LoA-040 : TppBankingApi.listOfAccounts Forwards the PSU request to TPP. See TppBankingApi.listOfAccounts . LoA-041 TppBankingApi.checkAuthorization verifies the authenticity of the Authorization header \"FinTechContext\". Returns the extracted fintechId. LoA-042 TppBankingApi.serviceSpec Put service parameter in a serviceSpec map for further processing. LoA-043 TppBankingApi.serviceContext Put all objects associated with the call into a generic ServiceContext object. LoA-050 BankingProtocolFacade.service Forwards the call to the BankingProtocolFacade. LoA-051, -052 BankingProtocolFacade.selectBankingProtocol If the serviceSessionId exists, selects the BankingProtocol based on the given serviceSessionId. If the is the very first request, there is no serviceSessionId and the TppBankingApi selects the BankingProtocol based on the given: BankId and ServiceType (in this case \"listOfAccounts\") LoA-060 : BankingProtocol.service The BankingProtocol associated with the given BankProfile decides on how to proceed with the request after loading and analyzing an eventually stored TppConsentSession. LoA-061 : BankingProtocol.define This step maps service parameter to be used in further processing to variable names for beter readability in subsequent calls. LoA-062 .. -064 : BankingProtocol.handelServiceSession If there is an existing serviceSessionId, it will be introspected to extract the id (bpServiceSessionID) and the key (bpServiceSessionKey) used to read and decrypt the persistent service session. The existing service session will be loaded. If the is no existing service session, a new one will be instantiated, returning the newly persistet ServiceSession and the corresponding encryption key. Note that all information associated with the service call are stored encrypted in the service session. The returned serviceSessionKey that can be used to decrypt the serviceSession. LoA-065 : BankingProtocol.externalId Creates an external serviceSessionId based on the internal bpServiceSessionId and bpServiceSessionKey. LoA-066 : BankingProtocol.findMatchingConsent use information provided to find a consent matching the service request. LoA-067 : BankingProtocol.updateServiceSession Finaly updates the persistent service session with all prepared information. LoA-070 .. -073 : No Suitable Consent Present: Create an Authorization Session If there is no suitable consent available, the BankingProtocol updates the ServiceSession with a new authorization session identified by an auth-id (unique in the scope of the user/serviceSession). - The auth-id: is an identifier of the authorization instance in the context of this PSU. It can be a short alphanumeric string like \"asrfvs\" used to isolate parallel active authorization sessions from each order. - In LoA-071 mapFinTechRedirectUrl this auth-id will be added as a query parameter Fintech-Redirect-URL-[OK|NOK] . - The redirectCode generated contains the serviceSessionID and the auth-id. The redirectCode is used by the ConsentAuthorizationApi of the TPP to access the service record. - The tppConsentEntryPoint is the static entry point of the ConsentAuthorisationApi extended with the query parameter redirectCode. LoA-074, LoA-075: Initiate Redirect By returning the BankingProtocolResponse (authId,serviceSessionID,tppConsentEntryPoint,redirectExp), the BankingProtocol instructs the BankingProtocolFacade, and the TppBankingApi to initiate a redirect of the PSU to the ConsentAuthorizationApi. LoA-076 TppBankingApi:303_SeeOther The TppBankingApi turns the BankingProtocolResponse into a 303_SeeOther(authId,serviceSessionID,\\ntppConsentEntryPoint,redirectExp). LoA-077 FinTechApi.storeServiceSessionId Before return control to the FinTechUI, the FinTechApi stores the returned serviceSessionID for future references. LoA-078 FinTechApi.expireSessionCookie(SessionCookie) Upon redirecting the PSU user agent to the ConsentAuthorizationApi, the regular session between the FinTechUI and the FinTechApi has to be removed in order to avoid unwanted access to the FinTechApi. Even though this is not mandatory as the SessionCookie is protected by an X-XSRF-TOKEN, it is still advisable to do this as the X-XSRF-TOKEN is eventually accessible to javascript code running in the UserAgent. LoA-079 FinTechApi.createRedirectCookie Purpose: The RedirectCookie is used make sure that the UserAgent that started a redirect flow is the same as the one the terminated that redirect flow. This is essential to assume that the PSU physically using this user agent is the same as the one that accessed the authorization interfaces of the (TPP resp. ASPSP). The RedirectCookie: is therefore set by the origin of the redirection (FinTech) and must be transported to the FinTechApi when control is sent back to the FinTechUI. Expiration: This RedirectCookie shall be set for the max time we think the PSU needs to complete authorization of the corresponding consent. Therefore the expiration of this RedirectCookie generally has a longer life span than the expiration of a regular SessionCookie. CookiePath (auth-id): This RedirectCookie must be bound to the fromConsentOk . This way, it does no need to be transported to the FinTechApi with any other request. Recall that the auth-id is part of the url. So each authorization session has his own RedirectCookie. XSRF Protection (X-XSRF-TOKEN): This RedirectCookie is also protected by an xsrfToken that is returned to the FinTechUI as header parameter. User Session : Generally processing a successful redirect is equivalent to a successful re-establishment of the user session. Meaning that FinTechApi can set a new SessionCookie to maintain the session with the PSU without a new explicit login of the PSU. LoA-080 : FinTechApi redirects userAgent to the ConsentAuthorisationApi The service response carries a response code 202 instructing the FinTechUI to redirect the PsuUserDevice to the ConsentAuthorisationApi. See 202_ToConsentAuthApi . LoA-090 Suitable Consent Present If there is a suitable consent reference in the database of the TPP, this will be loaded and used to forward request to the ASPSP. LoA-091 : Forward Service Request to ASPSP Service request is forwarded to the AspspBankingApi together with a reference to an AisConsent. The Associated TppContext contains TPP identifying information. LoA-092 .. LoA-95 : Returned Service Response if sent and displayed to the PSU. The returned ListOfAccountsResponse is wrapped into a BankingProtocolResponse that will travel through the call chain back to the FinTechApi. LoA-096 FinTechApi.storeServiceSessionId The FinTechApi will first store the service session for future reference. LoA-096 FinTechApi:200_Accounts The FinTechApi returns the payload to the FinTechUI together with a new SessionCookie.","title":"List of Accounts"},{"location":"architecture/4a-aisListOfAccounts/#list-of-accounts","text":"General terms defined in the dictionary","title":"List Of Accounts"},{"location":"architecture/4a-aisListOfAccounts/#definition","text":"Requests the list of bank accounts associated with this PSU's online banking account at the target ASPSP. If there is any reference to an existing account information consent (AisConsent) stored in the database of the TPP, the TPP will use this consent reference to forward the service request to the OpenBanking interface of the ASPSP. If there is no such reference in the database of the TPP, the TPP will respond the FinTech to redirect the PSU to the ConsentAuthorizationApi of the TPP.","title":"Definition"},{"location":"architecture/4a-aisListOfAccounts/#identifying-the-psu","text":"In order to uniquely identify the requesting PSU, the TPP uses a unique reference made out of: * the fintechId : the unique identifier of this FinTech in the realm of the TPP. This parameter is read from the FinTechContext transported as jwt-Token in the authorization header of each FinTech request to the TPP. * the psu-id@fintech : the unique identifier of the PSU in the realm of the FinTech. This parameter is transported in the HttpHeader named: Fintech-User-ID * PsuAuthData : this is an object opaque to the FinTechAPI and contains additional context information provided by the tpp and to be stored by the FinTechApi and provided if available through the corresponding header field.","title":"Identifying the PSU"},{"location":"architecture/4a-aisListOfAccounts/#mapping-psu-requests-to-consent","text":"The complexity of mapping a PSU service request to an existing consent is kept in the database of the TPP. The only responsibility of a FinTech is to: * provide a unique psu-id@fintech per PSU * add the the PsuAuthData to the request if available * to associate the psu-id@fintech with a newly returned PsuAuthData and store this in the database of the FinTechAPI.","title":"Mapping PSU Requests to Consent"},{"location":"architecture/4a-aisListOfAccounts/#diagram","text":"","title":"Diagram"},{"location":"architecture/4a-aisListOfAccounts/#use-cases","text":"","title":"Use Cases"},{"location":"architecture/4a-aisListOfAccounts/#loa-010-fintechuidisplaybankservices","text":"The result of a bank selection is that the FinTechUI displays the BankProfile to the PSU. The bank profile contains the list of services offered by the selected bank. For account information, this list generally contains only the first service \"listOfAccounts\" as all other account information services rely on the target account selected and identified by account-id.","title":"LoA-010 FinTechUI.displayBankServices"},{"location":"architecture/4a-aisListOfAccounts/#loa-020-fintechuiselectservicelistofaccounts","text":"Once selected by the PSU, the FinTechUI forwards the service selected to the FinTechApi. In this case \"listOfAccounts\". The selection might be accompanied with some service specifications. For listOfAccounts, the option withBalance can be added to indicate that the balance has to be returned as well.","title":"LoA-020 : FinTechUI.selectService(listOfAccounts)"},{"location":"architecture/4a-aisListOfAccounts/#loa-021-fintechuireadredirecturlsfintech-redirect-url-okfintech-redirect-url-nok","text":"Prepare the redirect urls associated with this request. These are URL used to start the UI from the ConsentAuthorizeAPI.","title":"LoA-021 : FinTechUI.readRedirectUrls(Fintech-Redirect-URL-OK,Fintech-Redirect-URL-NOK)"},{"location":"architecture/4a-aisListOfAccounts/#loa-031-fintechapicheckauthorization","text":"Call specification: : checkAuthorization(SessionCookie,X-XSRF-TOKEN):psu-id@fintech Before proceeding with the request, the FinTechApi must validate the request for it authenticity and extract a unique identifier of the PSU in the world of the FinTech (psu-id@fintech). This validation also include the matching of the used cookie against the provided XSRF-Token.","title":"LoA-031 : FinTechApi.checkAuthorization"},{"location":"architecture/4a-aisListOfAccounts/#loa-033-fintechapiloadservicesession-deprecated","text":"","title":"LoA-033 : FinTechApi.loadServiceSession (Deprecated)"},{"location":"architecture/4a-aisListOfAccounts/#loa-040-tppbankingapilistofaccounts","text":"Forwards the PSU request to TPP. See TppBankingApi.listOfAccounts .","title":"LoA-040 : TppBankingApi.listOfAccounts"},{"location":"architecture/4a-aisListOfAccounts/#loa-041-tppbankingapicheckauthorization","text":"verifies the authenticity of the Authorization header \"FinTechContext\". Returns the extracted fintechId.","title":"LoA-041 TppBankingApi.checkAuthorization"},{"location":"architecture/4a-aisListOfAccounts/#loa-042-tppbankingapiservicespec","text":"Put service parameter in a serviceSpec map for further processing.","title":"LoA-042 TppBankingApi.serviceSpec"},{"location":"architecture/4a-aisListOfAccounts/#loa-043-tppbankingapiservicecontext","text":"Put all objects associated with the call into a generic ServiceContext object.","title":"LoA-043 TppBankingApi.serviceContext"},{"location":"architecture/4a-aisListOfAccounts/#loa-051-052-bankingprotocolfacadeselectbankingprotocol","text":"If the serviceSessionId exists, selects the BankingProtocol based on the given serviceSessionId. If the is the very first request, there is no serviceSessionId and the TppBankingApi selects the BankingProtocol based on the given: BankId and ServiceType (in this case \"listOfAccounts\")","title":"LoA-051, -052 BankingProtocolFacade.selectBankingProtocol"},{"location":"architecture/4a-aisListOfAccounts/#loa-061-bankingprotocoldefine","text":"This step maps service parameter to be used in further processing to variable names for beter readability in subsequent calls.","title":"LoA-061 : BankingProtocol.define"},{"location":"architecture/4a-aisListOfAccounts/#loa-062-064-bankingprotocolhandelservicesession","text":"If there is an existing serviceSessionId, it will be introspected to extract the id (bpServiceSessionID) and the key (bpServiceSessionKey) used to read and decrypt the persistent service session. The existing service session will be loaded. If the is no existing service session, a new one will be instantiated, returning the newly persistet ServiceSession and the corresponding encryption key. Note that all information associated with the service call are stored encrypted in the service session. The returned serviceSessionKey that can be used to decrypt the serviceSession.","title":"LoA-062 .. -064  : BankingProtocol.handelServiceSession"},{"location":"architecture/4a-aisListOfAccounts/#loa-065-bankingprotocolexternalid","text":"Creates an external serviceSessionId based on the internal bpServiceSessionId and bpServiceSessionKey.","title":"LoA-065 : BankingProtocol.externalId"},{"location":"architecture/4a-aisListOfAccounts/#loa-066-bankingprotocolfindmatchingconsent","text":"use information provided to find a consent matching the service request.","title":"LoA-066 : BankingProtocol.findMatchingConsent"},{"location":"architecture/4a-aisListOfAccounts/#loa-067-bankingprotocolupdateservicesession","text":"Finaly updates the persistent service session with all prepared information.","title":"LoA-067 : BankingProtocol.updateServiceSession"},{"location":"architecture/4a-aisListOfAccounts/#loa-074-loa-075-initiate-redirect","text":"By returning the BankingProtocolResponse (authId,serviceSessionID,tppConsentEntryPoint,redirectExp), the BankingProtocol instructs the BankingProtocolFacade, and the TppBankingApi to initiate a redirect of the PSU to the ConsentAuthorizationApi.","title":"LoA-074, LoA-075: Initiate Redirect"},{"location":"architecture/4a-aisListOfAccounts/#loa-092-loa-95-returned-service-response-if-sent-and-displayed-to-the-psu","text":"The returned ListOfAccountsResponse is wrapped into a BankingProtocolResponse that will travel through the call chain back to the FinTechApi.","title":"LoA-092 .. LoA-95 : Returned Service Response if sent and displayed to the PSU."},{"location":"architecture/4a-aisListOfAccounts/#loa-096-fintechapistoreservicesessionid","text":"The FinTechApi will first store the service session for future reference.","title":"LoA-096 FinTechApi.storeServiceSessionId"},{"location":"architecture/4a-aisListOfAccounts/#loa-096-fintechapi200_accounts","text":"The FinTechApi returns the payload to the FinTechUI together with a new SessionCookie.","title":"LoA-096 FinTechApi:200_Accounts"},{"location":"architecture/4b-aisListOfTransactions/","text":"List Of Transactions General terms defined in the dictionary Definition Request the list of transactions for a given bank account. If there is any reference to an existing account information consent (AisConsent) stored in the database of the TPP, the TPP will use this consent reference to forward the service request to the OpenBanking interface of the ASPSP. If there is no such reference in the database of the TPP, the TPP will respond the FinTech to redirect the PSU to the ConsentAuthorizationApi of the TPP. In order to uniquely identify the requesting PSU, the TPP uses a unique reference made out of: - the fintechId : the unique identifier of this FinTech in the realm of the TPP. This parameter is read from the FinTechContext transported as jwt-Token in the Authorization header of each FinTech request to the TPP. - the psu-id@fintech : the unique identifier of the PSU in the realm of the FinTech. This parameter is transported in the HttpHeader named: Fintech-User-ID Diagram Use Cases LoT-010 FinTechUI.displayBankAccount(BankAccount) After receiving the list of accounts, the FinTechUI can dsiplay a single bank account to the PSU. LoT-020 : FinTechUI.selectService(listTransactions) On of the services available when the FinTechUI present bank account details to the PSU is the \"listOfTransactions\". If selected by the PSU, the FinTechUI forwards the service call to the FinTechApi. The selection must be accompanied with some mandatory and optional service specifications. For example in the case of listOfTransactions, this the account-id is part of the request path and indicates the target account. The ListTransactionsSpec is used to describe additional optional request parameters. LoA-021 : FinTechUI.readRedirectUrls(Fintech-Redirect-URL-OK,Fintech-Redirect-URL-NOK) Read the redirect urls associated with this context. These are URL used to start the UI from the ConsentAuthorizeAPI. LoT-030 : FinTechApi.listOfTransactions Call specification: See [](See FinTechApi.listOfAccounts The FinTechUI issues a listOfTransactions request to the FinTechAPI with: - SessionCookie and X-XSRF-TOKEN: The SessionCookie used to maintain association between FinTechUI and FinTechApi. It holds a session identifier. A corresponding XSRF-TOKEN is sent back and forth though the header and used to authenticate the SessionCookie. - The bank-id: passed as a query parameter and referencing the given BankProfile that contains meta information associated with the selected Bank. - The account-id: is sent as a path parameter and references the target bank account. - dateFrom: Starting date (inclusive the date dateFrom) of the transaction list, mandated if no delta access is required. For booked transactions, the relevant date is the booking date. For pending transactions, the relevant date is the entry date, which may not be transparent neither in this API nor other channels of the ASPSP. - dateTo: End date (inclusive the data dateTo) of the transaction list, default is \"now\" if not given. Might be ignored if a delta function is used. For booked transactions, the relevant date is the booking date. For pending transactions, the relevant date is the entry date, which may not be transparent neither in this API nor other channels of the ASPSP. - deltaList: This data attribute indicates that the FinTech is in favour to get all transactions after the last report access for this PSU on the addressed account. - entryReferenceFrom: This data attribute indicates that the FinTech is in favour to get all transactions after the transaction with identification entryReferenceFrom alternatively to the above defined period. This is an implementation of a delta access. If this data element is contained, the entries \"dateFrom\" and \"dateTo\" might be ignored by the ASPSP. - bookingStatus: To support the \"pending\" and \"both\" feature is optional for the ASPSP, Error code if not supported in the online banking frontend Default is \"booked\". - X-Request-ID: unique identifier that identifies this request throughout the entire processing chain. Shall be contained in HTTP Response as well. LoT-031 : FinTechApi.checkAuthorization Call specification: : checkAuthorization(SessionCookie,\\nX-XSRF-TOKEN):psu-id@fintech Before proceeding with the request, the FinTechApi must validate the request for it authenticity and extract a unique identifier of the PSU in the world of the FinTech (psu-id@fintech). This validation also include the matching of the used cookie against the provided XSRF-Token. LoT-032 : FinTechApi.userAgentContext Parses the HTTP request and extract information associated with the user agent (see UserAgentContext ). The UserAgentContext describes details associated with the user agent of the PSU. Generally not visible in the API as they are automatically provided by the user agent. The purpose is to transfer context specific information on both current Request and PsuUserAgent. Those information might later be required by the ASPSP like. Below is a non exhaustive list of UserAgent specific context information: * IP-Address, * IP-Port, * Accept, * Accept-Charset, * Accept-Encoding, * Accept-Language, * Device-ID, * User-Agent, * PSU-Geo-Location, * Http-Method. LoT-033 : FinTechApi.loadServiceSession Uses the given psu-id and service type to load a corresponding service session if the FinTech judges the request of the PSU is the repetition of an existing service request. LoT-040 : TppBankingApi.listOfTransactions Forwards the PSU request to TPP. See TppBankingApi.listOfAccounts . LoT-041 TppBankingApi.checkAuthorization verifies the authenticity of the Authorization header \"FinTechContext\". Returns the extracted fintechId. LoT-042 TppBankingApi.serviceSpec Put service parameter in a serviceSpec map for further processing. LoT-043 TppBankingApi.serviceContext Put all objects associated with the call into a generic ServiceContext object. LoT-050 .. LoT-052 BankingProtocolFacade.service See ListOfAccounts LoT-060 .. LoT-067 : BankingProtocol.service See ListOfAccounts LoA-070 .. -080 : No Suitable Consent Present. Redirect See ListOfAccounts LoA-090 Suitable Consent Present If there is a suitable consent reference in the database of the TPP, this will be loaded and used to forward request to the ASPSP. LoA-091 : Forward Service Request to ASPSP Service request is forwarded to the AspspBankingApi together with a reference to an AisConsent. The Associated TppContext contains TPP identifying information. LoA-092 .. LoA-95 : Returned Service Response The returned ListOfTransactionsResponse is wrapped into a BankingProtocolResponse that will travel through the call chain back to the FinTechApi. LoA-096 FinTechApi.storeServiceSessionId The FinTechApi will first store the service session for future reference. LoA-096 FinTechApi:200_Accounts The FinTechApi returns the payload to the FinTechUI together with a new SessionCookie.","title":"List of Transactions"},{"location":"architecture/4b-aisListOfTransactions/#list-of-transactions","text":"General terms defined in the dictionary","title":"List Of Transactions"},{"location":"architecture/4b-aisListOfTransactions/#definition","text":"Request the list of transactions for a given bank account. If there is any reference to an existing account information consent (AisConsent) stored in the database of the TPP, the TPP will use this consent reference to forward the service request to the OpenBanking interface of the ASPSP. If there is no such reference in the database of the TPP, the TPP will respond the FinTech to redirect the PSU to the ConsentAuthorizationApi of the TPP. In order to uniquely identify the requesting PSU, the TPP uses a unique reference made out of: - the fintechId : the unique identifier of this FinTech in the realm of the TPP. This parameter is read from the FinTechContext transported as jwt-Token in the Authorization header of each FinTech request to the TPP. - the psu-id@fintech : the unique identifier of the PSU in the realm of the FinTech. This parameter is transported in the HttpHeader named: Fintech-User-ID","title":"Definition"},{"location":"architecture/4b-aisListOfTransactions/#diagram","text":"","title":"Diagram"},{"location":"architecture/4b-aisListOfTransactions/#use-cases","text":"","title":"Use Cases"},{"location":"architecture/4b-aisListOfTransactions/#lot-010-fintechuidisplaybankaccountbankaccount","text":"After receiving the list of accounts, the FinTechUI can dsiplay a single bank account to the PSU.","title":"LoT-010 FinTechUI.displayBankAccount(BankAccount)"},{"location":"architecture/4b-aisListOfTransactions/#lot-020-fintechuiselectservicelisttransactions","text":"On of the services available when the FinTechUI present bank account details to the PSU is the \"listOfTransactions\". If selected by the PSU, the FinTechUI forwards the service call to the FinTechApi. The selection must be accompanied with some mandatory and optional service specifications. For example in the case of listOfTransactions, this the account-id is part of the request path and indicates the target account. The ListTransactionsSpec is used to describe additional optional request parameters.","title":"LoT-020 : FinTechUI.selectService(listTransactions)"},{"location":"architecture/4b-aisListOfTransactions/#loa-021-fintechuireadredirecturlsfintech-redirect-url-okfintech-redirect-url-nok","text":"Read the redirect urls associated with this context. These are URL used to start the UI from the ConsentAuthorizeAPI.","title":"LoA-021 : FinTechUI.readRedirectUrls(Fintech-Redirect-URL-OK,Fintech-Redirect-URL-NOK)"},{"location":"architecture/4b-aisListOfTransactions/#lot-031-fintechapicheckauthorization","text":"Call specification: : checkAuthorization(SessionCookie,\\nX-XSRF-TOKEN):psu-id@fintech Before proceeding with the request, the FinTechApi must validate the request for it authenticity and extract a unique identifier of the PSU in the world of the FinTech (psu-id@fintech). This validation also include the matching of the used cookie against the provided XSRF-Token.","title":"LoT-031 : FinTechApi.checkAuthorization"},{"location":"architecture/4b-aisListOfTransactions/#lot-033-fintechapiloadservicesession","text":"Uses the given psu-id and service type to load a corresponding service session if the FinTech judges the request of the PSU is the repetition of an existing service request.","title":"LoT-033 : FinTechApi.loadServiceSession"},{"location":"architecture/4b-aisListOfTransactions/#lot-040-tppbankingapilistoftransactions","text":"Forwards the PSU request to TPP. See TppBankingApi.listOfAccounts .","title":"LoT-040 : TppBankingApi.listOfTransactions"},{"location":"architecture/4b-aisListOfTransactions/#lot-041-tppbankingapicheckauthorization","text":"verifies the authenticity of the Authorization header \"FinTechContext\". Returns the extracted fintechId.","title":"LoT-041 TppBankingApi.checkAuthorization"},{"location":"architecture/4b-aisListOfTransactions/#lot-042-tppbankingapiservicespec","text":"Put service parameter in a serviceSpec map for further processing.","title":"LoT-042 TppBankingApi.serviceSpec"},{"location":"architecture/4b-aisListOfTransactions/#lot-043-tppbankingapiservicecontext","text":"Put all objects associated with the call into a generic ServiceContext object.","title":"LoT-043 TppBankingApi.serviceContext"},{"location":"architecture/4b-aisListOfTransactions/#lot-050-lot-052-bankingprotocolfacadeservice","text":"See ListOfAccounts","title":"LoT-050 .. LoT-052 BankingProtocolFacade.service"},{"location":"architecture/4b-aisListOfTransactions/#lot-060-lot-067-bankingprotocolservice","text":"See ListOfAccounts","title":"LoT-060 .. LoT-067 : BankingProtocol.service"},{"location":"architecture/4b-aisListOfTransactions/#loa-070-080-no-suitable-consent-present-redirect","text":"See ListOfAccounts","title":"LoA-070 .. -080 : No Suitable Consent Present. Redirect"},{"location":"architecture/4b-aisListOfTransactions/#loa-092-loa-95-returned-service-response","text":"The returned ListOfTransactionsResponse is wrapped into a BankingProtocolResponse that will travel through the call chain back to the FinTechApi.","title":"LoA-092 .. LoA-95 : Returned Service Response"},{"location":"architecture/4b-aisListOfTransactions/#loa-096-fintechapistoreservicesessionid","text":"The FinTechApi will first store the service session for future reference.","title":"LoA-096 FinTechApi.storeServiceSessionId"},{"location":"architecture/4b-aisListOfTransactions/#loa-096-fintechapi200_accounts","text":"The FinTechApi returns the payload to the FinTechUI together with a new SessionCookie.","title":"LoA-096 FinTechApi:200_Accounts"},{"location":"architecture/5-redirectPsuToConsentAPI/","text":"Initiate AisConsent Diagram InitConsent-010 ConsentAuthorisationApi The redirect starts with a get request to ConsentAuthorisationApi.auth. The entryPoint of the ConsentAuthorisationApi for processing a consent initiated on the TppBankingApi side. InitConsent-020 BankingProtocolFacade.redirectSession(redirectCode) The ConsentAuthorisationApi forwards the redirect call to the BankingProtocolFacade. InitConsent-030 BankingProtocolFacade.loadDecryptRedirectSession(redirectCode) The redirectCOde is used to load and decrypt the redirecSession. InitConsent-031 BankingProtocolFacade.selectBankingProtocol(serviceSessionId) BankingProtocolFacade will read the serviceSessionId from the redirectSession and use it to load the matching BankingProtocol. InitConsent-040 BankingProtocol.redirectSession(serviceSessionId, authId) The BankingProtocolFacade forwards the redirect call to the BankingProtocol. InitConsent-041, -042 : BankingProtocol.handelServiceSession The serviceSessionID will be introspected to extract the bpServiceSessionID and the bpServiceSessionKey used to read and decrypt the persistent service session PreAuthentication Required Some OpenBanking protocols required the PsuId to be provided with the very initial consent initiation request. In some cases, the OpenBanking protocol will specify a way to collect the PSU identity. This is the approach taken by the AuthPreStep as defined by the NextGenPSD2 protocol. In some other cases, the OpenBanking will not define any way of collecting this PSU identity. In such a case, the PsuIdentity will be collected using a UI defined by the TPP. Depending on which interface is taken to collect the PsuIdentity, we will have to mark if this collected identity is authenticated or not. If the identity collection interface allow the provision of a password and verifycation of the association between the given identity and the password, we call this an authenticated identity. If the interface only provide a collection of the PsuIdentity without proof of ownership of this identity, will call this an unauthenticated identity. InitConsent-060 BankingProtocol:BankingProtocolResponse Inputs: (seviceSessionId, authId) If the protocol requires a PsuIdentity and does not specify an identity provider (e.g.: oAuth2) used to collect that identity, we assume the BankingProtocol is requesting the ConsentAuthorisationApi to collect the identity unauthenticated. In this case, the BankingProtocol will return an BankingProtocolResponse to instruct the BankingProtocolFacade to collect the identity of the PSU. The result carries following parameters: The seviceSessionId: contains information later used by the BankingProtocol to load the ServiceSession. The authId: references this authorization instance in the scope of a service session, as a service request can involve more that one authorization session. InitConsent-061 BankingProtocol:BankingProtocolResponse Inputs: (seviceSessionId, authId) The BankingProtocolFacade instructs the ConsentAuthorisationApi to collect the identity of the PSU. InitConsent-062 ConsentAuthorisationApi.createSessionCookie Inputs: (seviceSessionId, authId) Returns: SessionCookie,state The ConsentAuthorisationApi creates a SessionCookie containing information provided in the call, generates a state parameter to protect the SessionCookie and redirects the call to the psuIdScreen of the ConsentAuthorisationUI. InitConsent-063 ConsentAuthorisationUI.redirect302 Specification: redirect302[SessionCookie,ConsentAuthorisationUI.psuIdScreen() The ConsentAuthorisationApi instructs the PsuUserDevice to redirect the PSU to the psuIdScreen of the ConsentAuthorisationUI. InitConsent-064 ConsentAuthorisationUI:displayPsuIdScreen The ConsentAuthorisationUI displays the psuIdScreen to the PSU. InitConsent-065 ConsentAuthorisationUI.enterPsuId The PSU enters the aspsp's PsuId in the filed provided by the ConsentAuthorisationUI. InitConsent-066 ConsentAuthorisationApi.updatePsuIdentification Spec: updatePsuIdentification SessionCookie, X-XSRF-TOKEN The ConsentAuthorisationUI sends the the collected data to the ConsentAuthorisationApi. InitConsent-067 ConsentAuthorisationApi.validateSessionCookie Inputs: (SessionCookie,xsrfToken) Results: seviceSessionId, authId The ConsentAuthorisationApi uses the provided xsrfToken to validate authenticity of the SessionCookie and the extract processing information out of the cookie. InitConsent-068 BankingProtocolFacade.updatePsuIdentification Spec: updatePsuIdentification(psu-id@tpp, psu-id@aspsp, seviceSessionId, authId) The ConsentAuthorisationApi forwards the call to the BankingProtocolFacade. InitConsent-069 BankingProtocolFacade.selectBankingProtocol Spec: selectBankingProtocol(protocolId):BankingProtocol The BankingProtocolFacade uses the provided protocolId to select the target BankingProtocol. InitConsent-070 BankingProtocol.updatePsuIdentification Spec: updatePsuIdentification(psu-id@tpp, psu-id@aspsp, seviceSessionId ,authId) The BankingProtocolFacade forwards the call to the BankingProtocol. InitConsent-080 BankingProtocol:BankingProtocolResponse Inputs: (seviceSessionId, authId, idpUrl) If the protocol requires a PsuIdentity and do specify an identity provider (e.g.: oAuth2) used to collect that identity, we assume the idp is going to authenticate the PSU and therefore, the BankingProtocol will return a BankingProtocolResponse to instruct the BankingProtocolFacade to send the PSU to the specified Idp. The returned result carries following parameters: The seviceSessionId : contains information later used by the BankingProtocol to laod the ServiceSession. The authId: references this authorization instance in the scope of a service session, as a service request can involve more that one authorization session. The idpUrl the url of the idp used to collect the psu identity on behalf of the ASPSP. InitConsent-081 BankingProtocolFacade:BankingProtocolResponse Inputs: (protocolId,seviceSessionId, serviceSessionKey,authId,idpUrl) The BankingProtocolFacade instructs the ConsentAuthorisationApi to collect the identity of the PSU. InitConsent-082 ConsentAuthorisationApi.createSessionCookie Inputs: (seviceSessionId, authId, idpUrl) Returns: SessionCookie,state The ConsentAuthorisationApi creates a SessionCookie containing information provided in the call, generates a state parameter to protect the SessionCookie and redirects the call to the redirectInfoPage of the ConsentAuthorisationUI. InitConsent-083 ConsentAuthorisationUI.redirect302 Specification: redirect302[SessionCookie, ConsentAuthorisationUI.psuIdScreen() The ConsentAuthorisationApi instructs the PsuUserDevice to redirect the PSU to the redirectInfoPage of the ConsentAuthorisationUI. InitConsent-084 ConsentAuthorisationUI:displayRedirectInfoPage The ConsentAuthorisationUI displays the redirectInfoPage to the PSU. InitConsent-085 ConsentAuthorisationUI.confirmRedirect The PSU confirms the redirect to the idp of the ASPSP. InitConsent-086 ConsentAuthorisationApi.confirmRedirect Spec: confirmRedirect SessionCookie, X-XSRF-TOKEN The ConsentAuthorisationUI sends a redirect confirmation to the ConsentAuthorisationApi. InitConsent-087 ConsentAuthorisationApi.validateSessionCookie Inputs: (SessionCookie,xsrfToken) Results: seviceSessionId, authId, idpUrl The ConsentAuthorisationApi uses the provided xsrfToken to validate authenticity of the SessionCookie and the extract processing information out of the cookie. InitConsent-088 ConsentAuthorisationApi.createRedirectCookie Inputs: (seviceSessionId, authId, idpUrl) Results: RedirectCookie,state The ConsentAuthorisationApi creates a RedirectCookie containing those processing information and following specification: path: ConsentAuthorisationUI.fromIdpAuth exp: expected time needed by the PSU to authenticate with the idp of the ASPSP redirect-uri: ConsentAuthorisationUI.fromIdpAuth . This the uri that is going to be used by the idp to redirect the PSU back to the TPP. state: this is the state used to verify authenticity of the RedirectCookie. InitConsent-089 ConsentAuthorisationApi:redirect302 Spec: redirect302[RedirectCookie,\\nOnlineBankingApi.redirectEntryPoint]\\n() The ConsentAuthorisationApi instructs the ConsentAuthorisationUI to redirect the PSU to the idp of the ASPSP. InitConsent-091 BankingProtocolFacade.fromIdpAuth Spec: fromIdpAuth UserAgentContext,\\nRedirectCookie \\n With this call, the idp of the APSPS redirects the PsuUserDevice to the ConsentAuthorisationUI of the TPP. This call will InitConsent-092 ConsentAuthorisationApi.validateRedirectCookie Inputs: (RedirectCookie,state) Results: seviceSessionId, authId, idpUrl The ConsentAuthorisationApi uses the provided state parameter to validate authenticity of the RedirectCookie and then extract processing information out of the cookie. InitConsent-093 BankingProtocolFacade.code2Token Inputs: (code, seviceSessionId, authId, idpUrl) The ConsentAuthorisationApi forwards the call to the BankingProtocolFacade. InitConsent-094 BankingProtocolFacade.selectBankingProtocol Spec: selectBankingProtocol(seviceSessionId):BankingProtocol The BankingProtocolFacade uses the provided seviceSessionId to select the target BankingProtocol. InitConsent-095 BankingProtocol.code2Token Spec: code2Token(code, seviceSessionId, authId, idpUrl) The BankingProtocolFacade forwards the call to the target BankingProtocol. InitConsent-096 OnlineBankingApi.code2Token Spec: GET:code2Token TppContext The BankingProtocol calls the token endpoint of the idp of the ASPSP to request the token matching the returned authorization code. InitConsent-097 OnlineBankingApi:token The idp of the ASPSP returns a token to the banking protocol. InitConsent-098 BankingProtocol.psuId The banking protocol extracts the needed psu-id from the returned token. InitConsent-100 AspspBankingApi.initiateConsent Spec: initiateConsent UserAgentContext, TppContext, psu-id@aspsp The BankingProtocol sends an initiate consent request to the OpenBanking interface of the ASPSP (aka AspspBankingApi). InitConsent-101 AspspBankingApi:200_OK Spec: 200_OK(AisConsent, AspspRedirectInfo, AspspChallenges, seviceSessionId) The OpenBanking interface of the ASPSP returns information necessary to start the consent authorization process. AisConsent : a reference to the started ASPSP consent session AspspRedirectInfo: Information needed in case the TPP has to redirect the PSU to the OnlineBankingApi of the ASPSP AspspChallenges: Challenges and SCA meta information in case the TPP will have to collect PSU credentials at the ConsentAuthorisationApi. seviceSessionId: needed to read the serviceSession. InitConsent-102 BankingProtocol.addToServiceSession Spec: addToServiceSession(AisConsent,\\nAspspRedirectInfo,\\nAspspChallenges) The BankingProtocol stores the response of the call in the ServiceSession that also includes information like: protocolId, seviceSessionId, serviceSessionKey, authId. InitConsent-103 BankingProtocol:ServiceSession The BankingProtocol also returns the ServiceSession containing information necessary to start the consent authorization process. InitConsent-104 BankingProtocolFacade:ServiceSession The BankingProtocolFacade returns the ServiceSession containing information necessary to start the consent authorization process. InitConsent-105 ConsentAuthorisationApi.prepareResponse -Specs: prepareResponse(ServiceSession):xsrfToken,AuthorizeResponse,SessionCookie The ConsentAuthorisationApi prepares the response, producing: - AuthorizeResponse : that will be sent back to the ConsentAuthorisationUI and used to manage interaction with the PSU and the ConsentAuthorisationUI. - SessionCookie : that will be used to authenticate the interaction between the ConsentAuthorisationUI and the ConsentAuthorisationApi - xsrfToken : used to authenticate SessionCookie InitConsent-106 ConsentAuthorisationUI.displayBankLoginPage Spec: displayBankLoginPage SessionCookie,X-XSRF-Token If the AuthorizeResponse indicates that the consent authorization is going to happen at the interface of the TPP (ConsentAuthorisationApi), the initial screen for the processing of challenges will be displayed. InitConsent-107 ConsentAuthorisationUI.displayRedirectInfoPage Spec: displayRedirectInfoPage SessionCookie,X-XSRF-Token If the AuthorizeResponse indicates that the consent authorization process is going to happen at the interface of the ASPSP, the redirect info page will be displayed to the PSU, waiting for a confirmation to be redirected to the ASPSP online banking interface.","title":"Redirect to Consent Authorization API"},{"location":"architecture/5-redirectPsuToConsentAPI/#initiate-aisconsent","text":"","title":"Initiate AisConsent"},{"location":"architecture/5-redirectPsuToConsentAPI/#diagram","text":"","title":"Diagram"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-010-consentauthorisationapi","text":"The redirect starts with a get request to ConsentAuthorisationApi.auth. The entryPoint of the ConsentAuthorisationApi for processing a consent initiated on the TppBankingApi side.","title":"InitConsent-010 ConsentAuthorisationApi"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-020-bankingprotocolfacaderedirectsessionredirectcode","text":"The ConsentAuthorisationApi forwards the redirect call to the BankingProtocolFacade.","title":"InitConsent-020 BankingProtocolFacade.redirectSession(redirectCode)"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-030-bankingprotocolfacadeloaddecryptredirectsessionredirectcode","text":"The redirectCOde is used to load and decrypt the redirecSession.","title":"InitConsent-030 BankingProtocolFacade.loadDecryptRedirectSession(redirectCode)"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-031-bankingprotocolfacadeselectbankingprotocolservicesessionid","text":"BankingProtocolFacade will read the serviceSessionId from the redirectSession and use it to load the matching BankingProtocol.","title":"InitConsent-031 BankingProtocolFacade.selectBankingProtocol(serviceSessionId)"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-040-bankingprotocolredirectsessionservicesessionid-authid","text":"The BankingProtocolFacade forwards the redirect call to the BankingProtocol.","title":"InitConsent-040 BankingProtocol.redirectSession(serviceSessionId, authId)"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-041-042-bankingprotocolhandelservicesession","text":"The serviceSessionID will be introspected to extract the bpServiceSessionID and the bpServiceSessionKey used to read and decrypt the persistent service session","title":"InitConsent-041, -042 : BankingProtocol.handelServiceSession"},{"location":"architecture/5-redirectPsuToConsentAPI/#preauthentication-required","text":"Some OpenBanking protocols required the PsuId to be provided with the very initial consent initiation request. In some cases, the OpenBanking protocol will specify a way to collect the PSU identity. This is the approach taken by the AuthPreStep as defined by the NextGenPSD2 protocol. In some other cases, the OpenBanking will not define any way of collecting this PSU identity. In such a case, the PsuIdentity will be collected using a UI defined by the TPP. Depending on which interface is taken to collect the PsuIdentity, we will have to mark if this collected identity is authenticated or not. If the identity collection interface allow the provision of a password and verifycation of the association between the given identity and the password, we call this an authenticated identity. If the interface only provide a collection of the PsuIdentity without proof of ownership of this identity, will call this an unauthenticated identity.","title":"PreAuthentication Required"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-060-bankingprotocolbankingprotocolresponse","text":"Inputs: (seviceSessionId, authId) If the protocol requires a PsuIdentity and does not specify an identity provider (e.g.: oAuth2) used to collect that identity, we assume the BankingProtocol is requesting the ConsentAuthorisationApi to collect the identity unauthenticated. In this case, the BankingProtocol will return an BankingProtocolResponse to instruct the BankingProtocolFacade to collect the identity of the PSU. The result carries following parameters: The seviceSessionId: contains information later used by the BankingProtocol to load the ServiceSession. The authId: references this authorization instance in the scope of a service session, as a service request can involve more that one authorization session.","title":"InitConsent-060 BankingProtocol:BankingProtocolResponse"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-061-bankingprotocolbankingprotocolresponse","text":"Inputs: (seviceSessionId, authId) The BankingProtocolFacade instructs the ConsentAuthorisationApi to collect the identity of the PSU.","title":"InitConsent-061 BankingProtocol:BankingProtocolResponse"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-062-consentauthorisationapicreatesessioncookie","text":"Inputs: (seviceSessionId, authId) Returns: SessionCookie,state The ConsentAuthorisationApi creates a SessionCookie containing information provided in the call, generates a state parameter to protect the SessionCookie and redirects the call to the psuIdScreen of the ConsentAuthorisationUI.","title":"InitConsent-062 ConsentAuthorisationApi.createSessionCookie"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-063-consentauthorisationuiredirect302","text":"Specification: redirect302[SessionCookie,ConsentAuthorisationUI.psuIdScreen() The ConsentAuthorisationApi instructs the PsuUserDevice to redirect the PSU to the psuIdScreen of the ConsentAuthorisationUI.","title":"InitConsent-063 ConsentAuthorisationUI.redirect302"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-064-consentauthorisationuidisplaypsuidscreen","text":"The ConsentAuthorisationUI displays the psuIdScreen to the PSU.","title":"InitConsent-064 ConsentAuthorisationUI:displayPsuIdScreen"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-065-consentauthorisationuienterpsuid","text":"The PSU enters the aspsp's PsuId in the filed provided by the ConsentAuthorisationUI.","title":"InitConsent-065 ConsentAuthorisationUI.enterPsuId"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-066-consentauthorisationapiupdatepsuidentification","text":"Spec: updatePsuIdentification SessionCookie, X-XSRF-TOKEN The ConsentAuthorisationUI sends the the collected data to the ConsentAuthorisationApi.","title":"InitConsent-066 ConsentAuthorisationApi.updatePsuIdentification"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-067-consentauthorisationapivalidatesessioncookie","text":"Inputs: (SessionCookie,xsrfToken) Results: seviceSessionId, authId The ConsentAuthorisationApi uses the provided xsrfToken to validate authenticity of the SessionCookie and the extract processing information out of the cookie.","title":"InitConsent-067 ConsentAuthorisationApi.validateSessionCookie"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-068-bankingprotocolfacadeupdatepsuidentification","text":"Spec: updatePsuIdentification(psu-id@tpp, psu-id@aspsp, seviceSessionId, authId) The ConsentAuthorisationApi forwards the call to the BankingProtocolFacade.","title":"InitConsent-068 BankingProtocolFacade.updatePsuIdentification"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-069-bankingprotocolfacadeselectbankingprotocol","text":"Spec: selectBankingProtocol(protocolId):BankingProtocol The BankingProtocolFacade uses the provided protocolId to select the target BankingProtocol.","title":"InitConsent-069 BankingProtocolFacade.selectBankingProtocol"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-070-bankingprotocolupdatepsuidentification","text":"Spec: updatePsuIdentification(psu-id@tpp, psu-id@aspsp, seviceSessionId ,authId) The BankingProtocolFacade forwards the call to the BankingProtocol.","title":"InitConsent-070 BankingProtocol.updatePsuIdentification"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-080-bankingprotocolbankingprotocolresponse","text":"Inputs: (seviceSessionId, authId, idpUrl) If the protocol requires a PsuIdentity and do specify an identity provider (e.g.: oAuth2) used to collect that identity, we assume the idp is going to authenticate the PSU and therefore, the BankingProtocol will return a BankingProtocolResponse to instruct the BankingProtocolFacade to send the PSU to the specified Idp. The returned result carries following parameters: The seviceSessionId : contains information later used by the BankingProtocol to laod the ServiceSession. The authId: references this authorization instance in the scope of a service session, as a service request can involve more that one authorization session. The idpUrl the url of the idp used to collect the psu identity on behalf of the ASPSP.","title":"InitConsent-080 BankingProtocol:BankingProtocolResponse"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-081-bankingprotocolfacadebankingprotocolresponse","text":"Inputs: (protocolId,seviceSessionId, serviceSessionKey,authId,idpUrl) The BankingProtocolFacade instructs the ConsentAuthorisationApi to collect the identity of the PSU.","title":"InitConsent-081 BankingProtocolFacade:BankingProtocolResponse"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-082-consentauthorisationapicreatesessioncookie","text":"Inputs: (seviceSessionId, authId, idpUrl) Returns: SessionCookie,state The ConsentAuthorisationApi creates a SessionCookie containing information provided in the call, generates a state parameter to protect the SessionCookie and redirects the call to the redirectInfoPage of the ConsentAuthorisationUI.","title":"InitConsent-082 ConsentAuthorisationApi.createSessionCookie"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-083-consentauthorisationuiredirect302","text":"Specification: redirect302[SessionCookie, ConsentAuthorisationUI.psuIdScreen() The ConsentAuthorisationApi instructs the PsuUserDevice to redirect the PSU to the redirectInfoPage of the ConsentAuthorisationUI.","title":"InitConsent-083 ConsentAuthorisationUI.redirect302"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-084-consentauthorisationuidisplayredirectinfopage","text":"The ConsentAuthorisationUI displays the redirectInfoPage to the PSU.","title":"InitConsent-084 ConsentAuthorisationUI:displayRedirectInfoPage"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-085-consentauthorisationuiconfirmredirect","text":"The PSU confirms the redirect to the idp of the ASPSP.","title":"InitConsent-085 ConsentAuthorisationUI.confirmRedirect"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-086-consentauthorisationapiconfirmredirect","text":"Spec: confirmRedirect SessionCookie, X-XSRF-TOKEN The ConsentAuthorisationUI sends a redirect confirmation to the ConsentAuthorisationApi.","title":"InitConsent-086 ConsentAuthorisationApi.confirmRedirect"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-087-consentauthorisationapivalidatesessioncookie","text":"Inputs: (SessionCookie,xsrfToken) Results: seviceSessionId, authId, idpUrl The ConsentAuthorisationApi uses the provided xsrfToken to validate authenticity of the SessionCookie and the extract processing information out of the cookie.","title":"InitConsent-087 ConsentAuthorisationApi.validateSessionCookie"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-088-consentauthorisationapicreateredirectcookie","text":"Inputs: (seviceSessionId, authId, idpUrl) Results: RedirectCookie,state The ConsentAuthorisationApi creates a RedirectCookie containing those processing information and following specification: path: ConsentAuthorisationUI.fromIdpAuth exp: expected time needed by the PSU to authenticate with the idp of the ASPSP redirect-uri: ConsentAuthorisationUI.fromIdpAuth . This the uri that is going to be used by the idp to redirect the PSU back to the TPP. state: this is the state used to verify authenticity of the RedirectCookie.","title":"InitConsent-088 ConsentAuthorisationApi.createRedirectCookie"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-089-consentauthorisationapiredirect302","text":"Spec: redirect302[RedirectCookie,\\nOnlineBankingApi.redirectEntryPoint]\\n() The ConsentAuthorisationApi instructs the ConsentAuthorisationUI to redirect the PSU to the idp of the ASPSP.","title":"InitConsent-089 ConsentAuthorisationApi:redirect302"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-091-bankingprotocolfacadefromidpauth","text":"Spec: fromIdpAuth UserAgentContext,\\nRedirectCookie \\n With this call, the idp of the APSPS redirects the PsuUserDevice to the ConsentAuthorisationUI of the TPP. This call will","title":"InitConsent-091 BankingProtocolFacade.fromIdpAuth"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-092-consentauthorisationapivalidateredirectcookie","text":"Inputs: (RedirectCookie,state) Results: seviceSessionId, authId, idpUrl The ConsentAuthorisationApi uses the provided state parameter to validate authenticity of the RedirectCookie and then extract processing information out of the cookie.","title":"InitConsent-092 ConsentAuthorisationApi.validateRedirectCookie"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-093-bankingprotocolfacadecode2token","text":"Inputs: (code, seviceSessionId, authId, idpUrl) The ConsentAuthorisationApi forwards the call to the BankingProtocolFacade.","title":"InitConsent-093 BankingProtocolFacade.code2Token"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-094-bankingprotocolfacadeselectbankingprotocol","text":"Spec: selectBankingProtocol(seviceSessionId):BankingProtocol The BankingProtocolFacade uses the provided seviceSessionId to select the target BankingProtocol.","title":"InitConsent-094 BankingProtocolFacade.selectBankingProtocol"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-095-bankingprotocolcode2token","text":"Spec: code2Token(code, seviceSessionId, authId, idpUrl) The BankingProtocolFacade forwards the call to the target BankingProtocol.","title":"InitConsent-095 BankingProtocol.code2Token"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-096-onlinebankingapicode2token","text":"Spec: GET:code2Token TppContext The BankingProtocol calls the token endpoint of the idp of the ASPSP to request the token matching the returned authorization code.","title":"InitConsent-096 OnlineBankingApi.code2Token"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-097-onlinebankingapitoken","text":"The idp of the ASPSP returns a token to the banking protocol.","title":"InitConsent-097 OnlineBankingApi:token"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-098-bankingprotocolpsuid","text":"The banking protocol extracts the needed psu-id from the returned token.","title":"InitConsent-098 BankingProtocol.psuId"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-100-aspspbankingapiinitiateconsent","text":"Spec: initiateConsent UserAgentContext, TppContext, psu-id@aspsp The BankingProtocol sends an initiate consent request to the OpenBanking interface of the ASPSP (aka AspspBankingApi).","title":"InitConsent-100 AspspBankingApi.initiateConsent"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-101-aspspbankingapi200_ok","text":"Spec: 200_OK(AisConsent, AspspRedirectInfo, AspspChallenges, seviceSessionId) The OpenBanking interface of the ASPSP returns information necessary to start the consent authorization process. AisConsent : a reference to the started ASPSP consent session AspspRedirectInfo: Information needed in case the TPP has to redirect the PSU to the OnlineBankingApi of the ASPSP AspspChallenges: Challenges and SCA meta information in case the TPP will have to collect PSU credentials at the ConsentAuthorisationApi. seviceSessionId: needed to read the serviceSession.","title":"InitConsent-101 AspspBankingApi:200_OK"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-102-bankingprotocoladdtoservicesession","text":"Spec: addToServiceSession(AisConsent,\\nAspspRedirectInfo,\\nAspspChallenges) The BankingProtocol stores the response of the call in the ServiceSession that also includes information like: protocolId, seviceSessionId, serviceSessionKey, authId.","title":"InitConsent-102 BankingProtocol.addToServiceSession"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-103-bankingprotocolservicesession","text":"The BankingProtocol also returns the ServiceSession containing information necessary to start the consent authorization process.","title":"InitConsent-103 BankingProtocol:ServiceSession"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-104-bankingprotocolfacadeservicesession","text":"The BankingProtocolFacade returns the ServiceSession containing information necessary to start the consent authorization process.","title":"InitConsent-104 BankingProtocolFacade:ServiceSession"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-105-consentauthorisationapiprepareresponse","text":"-Specs: prepareResponse(ServiceSession):xsrfToken,AuthorizeResponse,SessionCookie The ConsentAuthorisationApi prepares the response, producing: - AuthorizeResponse : that will be sent back to the ConsentAuthorisationUI and used to manage interaction with the PSU and the ConsentAuthorisationUI. - SessionCookie : that will be used to authenticate the interaction between the ConsentAuthorisationUI and the ConsentAuthorisationApi - xsrfToken : used to authenticate SessionCookie","title":"InitConsent-105 ConsentAuthorisationApi.prepareResponse"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-106-consentauthorisationuidisplaybankloginpage","text":"Spec: displayBankLoginPage SessionCookie,X-XSRF-Token If the AuthorizeResponse indicates that the consent authorization is going to happen at the interface of the TPP (ConsentAuthorisationApi), the initial screen for the processing of challenges will be displayed.","title":"InitConsent-106 ConsentAuthorisationUI.displayBankLoginPage"},{"location":"architecture/5-redirectPsuToConsentAPI/#initconsent-107-consentauthorisationuidisplayredirectinfopage","text":"Spec: displayRedirectInfoPage SessionCookie,X-XSRF-Token If the AuthorizeResponse indicates that the consent authorization process is going to happen at the interface of the ASPSP, the redirect info page will be displayed to the PSU, waiting for a confirmation to be redirected to the ASPSP online banking interface.","title":"InitConsent-107 ConsentAuthorisationUI.displayRedirectInfoPage"},{"location":"architecture/5a-psuAuthEmbeddedConsent/","text":"Authorize Consent Embedded Approach Description Implements the process of collecting consent authorization credentials in an interface provided by the TPP as described EBA-RTS embedded approach. The authorization is designed as a recursive list of ChallengeResponse sessions. Diagram Use Cases AuthEmbedded-010 : Create ConsentAuthSessionCookie If the TppConsentSession has an authChallenge, the interaction starts with the initialization of a ConsentAuthSessionCookie . The ConsentAuthSessionCookie is encrypted with a key stored in the consentSessionState . AuthEmbedded-020 : Redirect to EmbeddedAuthInitScreen After preparation of the ConsentAuthSessionCookie, the UserAgent is redirected to the EmbeddedAuthInitScreen of the ConsentAuthorisationUI. AuthEmbedded-030-040 : Load AuthChallenges The generic endpoint at ConsentAuthorisationApi.embeddedAuth allows the ConsentAuthorisationUI to load AuthChallenges if any. The call returns the AuthorizeResponse that contains all information necessary to display returned challenges to the PSU. An ScaUIMetadaData object contain UI customization parameter. AuthEmbedded-050-060 : Display Auth Screen and Collect PSU Auth Data Using information contained in the AuthorizeResponse object, the ConsentAuthorisationUI will display the suitable AuthScreen to the PSU and use it to collect PsuAuthData. AuthEmbedded-070-087 : Send PsuAuthData to ConsentAuthorisationApi The generic endpoint at ConsentAuthorisationApi.embeddedAuth will finally be called again to send authentication data entered by the PSU to the BankingProtocol. AuthEmbedded-090-094 : Redirect to FinTechUI As the TppConsentSession presents no more AuthChallenge, a RedirectSession is prepared and the PSU is redirected back to the FinTechUI. This is done by returning a 302_Redirect to the ConsentAuthorisationUI.","title":"Authorize Consent Embedded Approach"},{"location":"architecture/5a-psuAuthEmbeddedConsent/#authorize-consent-embedded-approach","text":"","title":"Authorize Consent Embedded Approach"},{"location":"architecture/5a-psuAuthEmbeddedConsent/#description","text":"Implements the process of collecting consent authorization credentials in an interface provided by the TPP as described EBA-RTS embedded approach. The authorization is designed as a recursive list of ChallengeResponse sessions.","title":"Description"},{"location":"architecture/5a-psuAuthEmbeddedConsent/#diagram","text":"","title":"Diagram"},{"location":"architecture/5a-psuAuthEmbeddedConsent/#use-cases","text":"","title":"Use Cases"},{"location":"architecture/5a-psuAuthEmbeddedConsent/#authembedded-010-create-consentauthsessioncookie","text":"If the TppConsentSession has an authChallenge, the interaction starts with the initialization of a ConsentAuthSessionCookie . The ConsentAuthSessionCookie is encrypted with a key stored in the consentSessionState .","title":"AuthEmbedded-010 : Create ConsentAuthSessionCookie"},{"location":"architecture/5a-psuAuthEmbeddedConsent/#authembedded-020-redirect-to-embeddedauthinitscreen","text":"After preparation of the ConsentAuthSessionCookie, the UserAgent is redirected to the EmbeddedAuthInitScreen of the ConsentAuthorisationUI.","title":"AuthEmbedded-020 : Redirect to EmbeddedAuthInitScreen"},{"location":"architecture/5a-psuAuthEmbeddedConsent/#authembedded-030-040-load-authchallenges","text":"The generic endpoint at ConsentAuthorisationApi.embeddedAuth allows the ConsentAuthorisationUI to load AuthChallenges if any. The call returns the AuthorizeResponse that contains all information necessary to display returned challenges to the PSU. An ScaUIMetadaData object contain UI customization parameter.","title":"AuthEmbedded-030-040 : Load AuthChallenges"},{"location":"architecture/5a-psuAuthEmbeddedConsent/#authembedded-050-060-display-auth-screen-and-collect-psu-auth-data","text":"Using information contained in the AuthorizeResponse object, the ConsentAuthorisationUI will display the suitable AuthScreen to the PSU and use it to collect PsuAuthData.","title":"AuthEmbedded-050-060 : Display Auth Screen and Collect PSU Auth Data"},{"location":"architecture/5a-psuAuthEmbeddedConsent/#authembedded-070-087-send-psuauthdata-to-consentauthorisationapi","text":"The generic endpoint at ConsentAuthorisationApi.embeddedAuth will finally be called again to send authentication data entered by the PSU to the BankingProtocol.","title":"AuthEmbedded-070-087 : Send PsuAuthData to ConsentAuthorisationApi"},{"location":"architecture/5a-psuAuthEmbeddedConsent/#authembedded-090-094-redirect-to-fintechui","text":"As the TppConsentSession presents no more AuthChallenge, a RedirectSession is prepared and the PSU is redirected back to the FinTechUI. This is done by returning a 302_Redirect to the ConsentAuthorisationUI.","title":"AuthEmbedded-090-094 : Redirect to FinTechUI"},{"location":"architecture/5b-psuAuthRedirectConsent/","text":"Authorize Consent Redirect Approach Description Describes the process of redirecting a PSU to the Online Banking interface of it's ASPSP. Diagram Use Cases AuthRedirect-010 & -020 : Display RedirectInfoPage ConsentAuthorisationUI.infoPanel page uses information provided by the AuthorizeResponse to display a redirect to ASPSP info page to the PSU. AuthRedirect-030 & -040 : Grant Redirect The PSU interface might decide to either allow the PSU to explicitly confirm or deny the redirection to the ASPSP, or automatically proceed with this without the consent of the PSU. In both case, the ConsentAuthorisationUI has to invoke the FinTechApi.toAspspGrant that will in turn invoke the ConsentAuthorisationApi.toAspspGrant endpoint to generate the redirect response. Managing Redirection AuthRedirect-050 : Redirecting PSU to the ASPSP Detailed specification of the redirect process might depend on the specification of the ASPSP interface. Nevertheless, the returned redirect link carries an ConsentAuthSessionCookie that is used to store consent details in the User Agent of the PSU. As well, the consentAuthState shall be part of any BackRedirectURL (OKUrl, nokUrl) so ConsentAuthorisationApi can read the ConsentAuthSessionCookie when ASPSP sends back PSU to the ConsentAuthorisationApi. AuthRedirect-060 : Back-Redirecting PSU to the ConsentAuthorisationAPI The endpoint ConsentAuthorisationAPI.fromAspspOk consumes a redirect call from the ASPSP Online Banking. The corresponding URL contains a consentAuthState. The consentAuthState will the be used to retrieve the attached ConsentAuthSessionCookie whose content will in turn be used to read the TppConsentSession. AuthRedirect-071 .. AuthRedirect-073 : Forward call to BankingProtocol The fromAspspOk method of the BankingProtocol is called with TppConsentSession and aspspAuthCode. - The aspspAuthCode can be use to retrieve Token from ASPSP Token endpoint in case of an oAuth Approach. - The consent session contains any other information needed to manage the consent process. AuthRedirect-077 Redirect PSU to FinTechAPI The TppConsentSession is temporarily encrypted and stored in the form of a RedirectSession. Corresponding redirectCode is used to redirect PSU to the FinTechAPI redirect endpoint. ConsentAuthSessionCookie is deleted with start of this back redirect process.","title":"Authorize Consent Redirect Approach"},{"location":"architecture/5b-psuAuthRedirectConsent/#authorize-consent-redirect-approach","text":"","title":"Authorize Consent Redirect Approach"},{"location":"architecture/5b-psuAuthRedirectConsent/#description","text":"Describes the process of redirecting a PSU to the Online Banking interface of it's ASPSP.","title":"Description"},{"location":"architecture/5b-psuAuthRedirectConsent/#diagram","text":"","title":"Diagram"},{"location":"architecture/5b-psuAuthRedirectConsent/#use-cases","text":"","title":"Use Cases"},{"location":"architecture/5b-psuAuthRedirectConsent/#authredirect-010-020-display-redirectinfopage","text":"ConsentAuthorisationUI.infoPanel page uses information provided by the AuthorizeResponse to display a redirect to ASPSP info page to the PSU.","title":"AuthRedirect-010 &amp; -020 : Display RedirectInfoPage"},{"location":"architecture/5b-psuAuthRedirectConsent/#authredirect-030-040-grant-redirect","text":"The PSU interface might decide to either allow the PSU to explicitly confirm or deny the redirection to the ASPSP, or automatically proceed with this without the consent of the PSU. In both case, the ConsentAuthorisationUI has to invoke the FinTechApi.toAspspGrant that will in turn invoke the ConsentAuthorisationApi.toAspspGrant endpoint to generate the redirect response.","title":"AuthRedirect-030 &amp; -040 : Grant Redirect"},{"location":"architecture/5b-psuAuthRedirectConsent/#managing-redirection","text":"","title":"Managing Redirection"},{"location":"architecture/5b-psuAuthRedirectConsent/#authredirect-050-redirecting-psu-to-the-aspsp","text":"Detailed specification of the redirect process might depend on the specification of the ASPSP interface. Nevertheless, the returned redirect link carries an ConsentAuthSessionCookie that is used to store consent details in the User Agent of the PSU. As well, the consentAuthState shall be part of any BackRedirectURL (OKUrl, nokUrl) so ConsentAuthorisationApi can read the ConsentAuthSessionCookie when ASPSP sends back PSU to the ConsentAuthorisationApi.","title":"AuthRedirect-050 : Redirecting PSU to the ASPSP"},{"location":"architecture/5b-psuAuthRedirectConsent/#authredirect-060-back-redirecting-psu-to-the-consentauthorisationapi","text":"The endpoint ConsentAuthorisationAPI.fromAspspOk consumes a redirect call from the ASPSP Online Banking. The corresponding URL contains a consentAuthState. The consentAuthState will the be used to retrieve the attached ConsentAuthSessionCookie whose content will in turn be used to read the TppConsentSession.","title":"AuthRedirect-060 : Back-Redirecting PSU to the ConsentAuthorisationAPI"},{"location":"architecture/5b-psuAuthRedirectConsent/#authredirect-071-authredirect-073-forward-call-to-bankingprotocol","text":"The fromAspspOk method of the BankingProtocol is called with TppConsentSession and aspspAuthCode. - The aspspAuthCode can be use to retrieve Token from ASPSP Token endpoint in case of an oAuth Approach. - The consent session contains any other information needed to manage the consent process.","title":"AuthRedirect-071 .. AuthRedirect-073 : Forward call to BankingProtocol"},{"location":"architecture/5b-psuAuthRedirectConsent/#authredirect-077-redirect-psu-to-fintechapi","text":"The TppConsentSession is temporarily encrypted and stored in the form of a RedirectSession. Corresponding redirectCode is used to redirect PSU to the FinTechAPI redirect endpoint. ConsentAuthSessionCookie is deleted with start of this back redirect process.","title":"AuthRedirect-077 Redirect PSU to FinTechAPI"},{"location":"architecture/6-consume_api/","text":"Consume API after Consent Authorization Description This workflow starts with the redirect link leaving from either Authorize Consent Redirect Approach or Authorize Consent Embedded Approach . This redirect link will be used by the ConsetAuthorizeUI to start the FinTechUI. Diagram Use Cases BankingService-001 : FinTechUI.loadFinTechUI Receiving a 302_RedirectToFintech from the ConsentAuthorisationAPI, the ConsentAuthorisationUI starts the FinTechUI using the location param. BankingService-002 : FinTechUI.readXsrfToken The FinTechUI uses the provided auth-id to load the xsrfToken stored for the corresponding auth-id. BankingService-002 : FinTechUI.buildBackendUrl FinTechUI uses the provided auth-id to build the backendUrl used to forward the request to the FinTechAPI. The url has the form: /v1/{auth-id}/fromConsentOk. BankingService-010 : FinTechApi.fromConsentOk The FinTechAPI uses the provided xsrfToken and RedirectCookie to legitimate the redirect request. BankingService-020 : FinTechApi.validateRedirectCall The finTechConsentSessionState will be used to read and validate the corresponding FinTechConsentSessionCookie. BankingService-030 : TppBankingApi.code2Token This end point is invoked by the FinTechApi to retrieve token used to send subsequent service requests to the TppBankingApi. We call this token PsuConsentSession. BankingService-040 : BankingProtocol.code2Token Forward request to banking protocol. BankingService-048 : FinTechApi.storePsuConsent The returned PsuConsentSession is stored by the FinTechApi for future use. BankingService-049 : FinTechUI: 202_ReloadUI At the end of the consent process, the FinTechAPI issues a redirect to the FinTechUI to display the original page to the user. BankingService-050 : FinTechApi.listOfTransactions Upon displaying the original page, the FinTechUI can reissue the original request to the the FinTechAPI. BankingService-060 .. BankingService-067 Service Requests Regular execution of the banking service.","title":"Consume Service"},{"location":"architecture/6-consume_api/#consume-api-after-consent-authorization","text":"","title":"Consume API after Consent Authorization"},{"location":"architecture/6-consume_api/#description","text":"This workflow starts with the redirect link leaving from either Authorize Consent Redirect Approach or Authorize Consent Embedded Approach . This redirect link will be used by the ConsetAuthorizeUI to start the FinTechUI.","title":"Description"},{"location":"architecture/6-consume_api/#diagram","text":"","title":"Diagram"},{"location":"architecture/6-consume_api/#use-cases","text":"","title":"Use Cases"},{"location":"architecture/6-consume_api/#bankingservice-001-fintechuiloadfintechui","text":"Receiving a 302_RedirectToFintech from the ConsentAuthorisationAPI, the ConsentAuthorisationUI starts the FinTechUI using the location param.","title":"BankingService-001 : FinTechUI.loadFinTechUI"},{"location":"architecture/6-consume_api/#bankingservice-002-fintechuireadxsrftoken","text":"The FinTechUI uses the provided auth-id to load the xsrfToken stored for the corresponding auth-id.","title":"BankingService-002 : FinTechUI.readXsrfToken"},{"location":"architecture/6-consume_api/#bankingservice-002-fintechuibuildbackendurl","text":"FinTechUI uses the provided auth-id to build the backendUrl used to forward the request to the FinTechAPI. The url has the form: /v1/{auth-id}/fromConsentOk.","title":"BankingService-002 : FinTechUI.buildBackendUrl"},{"location":"architecture/6-consume_api/#bankingservice-010-fintechapifromconsentok","text":"The FinTechAPI uses the provided xsrfToken and RedirectCookie to legitimate the redirect request.","title":"BankingService-010 : FinTechApi.fromConsentOk"},{"location":"architecture/6-consume_api/#bankingservice-020-fintechapivalidateredirectcall","text":"The finTechConsentSessionState will be used to read and validate the corresponding FinTechConsentSessionCookie.","title":"BankingService-020 : FinTechApi.validateRedirectCall"},{"location":"architecture/6-consume_api/#bankingservice-030-tppbankingapicode2token","text":"This end point is invoked by the FinTechApi to retrieve token used to send subsequent service requests to the TppBankingApi. We call this token PsuConsentSession.","title":"BankingService-030 : TppBankingApi.code2Token"},{"location":"architecture/6-consume_api/#bankingservice-040-bankingprotocolcode2token","text":"Forward request to banking protocol.","title":"BankingService-040 : BankingProtocol.code2Token"},{"location":"architecture/6-consume_api/#bankingservice-048-fintechapistorepsuconsent","text":"The returned PsuConsentSession is stored by the FinTechApi for future use.","title":"BankingService-048 : FinTechApi.storePsuConsent"},{"location":"architecture/6-consume_api/#bankingservice-049-fintechui-202_reloadui","text":"At the end of the consent process, the FinTechAPI issues a redirect to the FinTechUI to display the original page to the user.","title":"BankingService-049 : FinTechUI: 202_ReloadUI"},{"location":"architecture/6-consume_api/#bankingservice-050-fintechapilistoftransactions","text":"Upon displaying the original page, the FinTechUI can reissue the original request to the the FinTechAPI.","title":"BankingService-050 : FinTechApi.listOfTransactions"},{"location":"architecture/6-consume_api/#bankingservice-060-bankingservice-067-service-requests","text":"Regular execution of the banking service.","title":"BankingService-060 .. BankingService-067 Service Requests"},{"location":"architecture/dictionary/","text":"Dictionary AisConsentSpec App ASPSP AspspBankingApi BankDescriptor BankingProtocolSelector BankingProtocol BankProfile ConsentAuthorisationApi ConsentAuthorisationUI ConsentData Dictionary FinTech FinTechApi FinTechContext FinTechDC FinTechUI Information OnlineBanking2ConsentAuthRedirectInfoPage OnlineBankingApi OnlineBankingConsentSessionCookie OnlineBankingLoginSessionCookie OnlineBankingUI PSU PsuConsentSession PsuIdentifier PsuUserAgent PsuUserDevice RedirectSession SessionCookie Sharing TppBankingApi TppBankSearchApi TppConsentSession TppContext TPP UserAgentContext WebBrowser ConsentData In the context of Open Banking, a consent encompasses all information necessary to provide a third party with the authorization to access banking services on behalf of the PSU. These are: - PSU banking identifier information known as (psuId, psuCorporateId) - PSU account details information (like account numbers, iban, ...) - PSU payment orders (including beneficiary names, amounts, ...) - PSU authentication methods All these information are stored in different devices during the consent authorization session. Form of storages are among others: - Held in the browser page for display to the PSU - Stored in the Cookie for reuse by the corresponding backend - Stored in backend databases for transfer to other server components - Stored in backend databases for reuse by server components. For the purpose of protecting these data, framework is designed to always have consent data encrypted while at rest or on transit. General logic is that encrypted payload and encryption key do not reside in the same environment, unless need for decryption and processing of those data. Following object hold consent data - TppConsentSession - RedirectSession - PsuConsentSession PsuUserDevice A PSU user device runs applications used by the PSU to access banking functionality. Those applications are generally called PsuUgerAgents. PsuUserAgent Application running on a PSU device and used by the PSU to access banking functionality. We are describing the two main types of PsuUserAgents. WebBrowser A Web browser is considered compliant in the context of this framework when it can protect specific information used between the PusUserDevice and the the corresponding server application to track the user session. For session tracking, this framework uses Cookies RFC6265 . Redirection and Data Sharing We assume all three applications FinTechApi, ConsentAuthorisationApi, OnlineBankingApi are hosted on different domains. This is, we are not expecting Cookies set by one application to be visible to another application (this might still happen on some local development environment, where everything runs on localhost). We also do not advice adding persistent information to RedirectUrl , as these are log files everywhere on infrastructure components in data centers. RedirectUrl shall instead carry OneTime and ShortLived authorization code we call code , that can be used to retrieved shared payload through an authenticated back channel connection. This is the practice borrowed from oAuth2 RFC6749 . Following table shows defined redirects and corresponding back chanel endpoints. Origin Application Redirecting Application Response Code; Location ; AuthCodeParam; Expiration Redirect Target Application Destination Application Data EndPoint at Origin Application TppBankingApi FinTechApi 302 ; /auth ; code ; 5s ConsentAuthorisationApi ConsentAuthorisationApi /loadTppConsentSession ConsentAuthorisationApi ConsentAuthorisationApi Proprietary banking API. Assume RFC6749. /auth OnlineBankingApi OnlineBankingApi none OnlineBankingApi OnlineBankingApi 302 ; [/ok|/nok] ; code ; 5s ConsentAuthorisationApi ConsentAuthorisationApi /token ConsentAuthorisationApi ConsentAuthorisationApi 302 ; [/ok|/nok] ; code ; 5s FinTechApi TppBankingApi /loadTppConsentSession Keeping Session Information We assume all three applications FinTechApi, ConsentAuthorisationApi, OnlineBankingApi maintain their own session information. This framework uses following terms to name the session information held by an application on the UserAgent of the PSU. Application SessionCookie FinTechApi Psu2FintechLoginSession ConsentAuthorisationApi ConsentAuthSessionCookie OnlineBankingApi OnlineBankingConsentSessionCookie Session information can also be kept across redirect life cycles. Upon redirecting the UserAgent to another application, the redirecting application can set Cookies that will be resent to the domain with future requests. This way, there will be no need to maintain user session information in temporary databases on the server, thus keeping server tiny. Native App The UserAgent might be a native application running on a user mobile device or a desktop computer. In this case, redirection might still take place, but with consideration of the physical transition between source and target UI-Application. Following specifications deal with security threads associated with the redirection between UI-Application on a user device: RFC8252:OAuth 2.0 for Native Apps , RFC7636:Proof Key for Code Exchange by OAuth Public Clients For the purpose of kepping the overall architecture of this framework simple, we will require native applications to provide the same behavior as the WebBrowser described above. UserAgentContext Independent on the type of PsuUgerAgent, OpenBanking interfaces will require transmission of a class of information associated with the PsuUserAgent so they can perform verification of the authenticity of the original PSU request and customize the response produced for intermediary layers. We group these data under the name \"UserAgentContext\". Following header names account among the UserAgentContext: IP-Address, IP-Port, Accept, Accept-Charset, Accept-Encoding, Accept-Language, Device-ID, User-Agent, Geo-Location, Http-Method. FinTechUI UI Application running on the PsuUserAgent and used by the PSU to access the FinTechApi ConsentAuthorisationUI UI used by PSU to authoraise consent in embedded case. OnlineBankingUI This UI manages the interaction between the PSU and the ASPSP in redirect cases. FinTech Organisation that uses Online Banking Services provided by TPP to service PSU with additional services. FinTech may or may not have own TPP License. FinTechDC Data center environment of the FinTech. Host the FinTechApi. FinTechApi Financial web service provided by the FinTech. Tpp Data Center Data center environment of the TPP TppBankingApi Tpp backend providing access to ASPSP banking functionality. This interface is not directly accessed by the PSU but by the FinTechApi. FinTechApi will use a FinTechContext to authenticate with the TppBankingApi. TppBankSearchApi Repository of banks maintained in the TPP's banking gateway. The banking search API will later presen an interface to configure profiles attached to listed banks. BankDescriptor Descriptive information assocaited with a bank like: - The name of the Bank - The address of the bank - The bank identification code BankProfile BankingApi profile information associated with a bank like: - The BankingProtocol used to connect with the bank - List of Banking services provided by the BankingApi of the bank - SCA approcahes associated with the BankingApi - ScaUIMetadaData: Screens and field used to collect user authentication data. - Actions to be performed by the PSU prior to using the BankingProtocol AisConsentSpec Specification associated with an AisConsent. This is highly dependent on the BankProfile. Following information might be carried by an AisConsentSpec object: - recurringIndicator - validUntil - frequencyPerDay - combinedService - accountAccessTemplate - availableAccounts[availableAccountsWithBalances, allAccounts] - allPsd2[allAccounts] FinTechContext Information used to identify the FinTech application at the TppBankingApi. For example a FinTech SSL client certificate or an APIKey or an oAuth2 Password Grant Credential. PSU A Payment Services User is a natural or legal person making use of a payment service as a payee, payer or both. PsuConsentSession Information associated with the consent as exchanged between the FinTechApi and the TppBankingApi. Generally contains: - Data needed to customize psu access at the ConsentAuthorisationApi (showInfoPanel, fintechStateHash) - Data needed to manage redirection of PSU from the TppConsentSession to the FintechUI like (FinTech-Redirect-URI, FinTech-Nok-Redirect-URI, FinTech-Explicit-Authorisation-Preferred, FinTech-Content-Negotiation) Object also contains information associated with the PSU requesting service if available. - The identifier of the PSU in the realm of the Tpp PsuIdentifier - Existing Consent References if any. PsuIdentifier This is the identifier of the PSU in the FinTech2Tpp relationship. This identifier can be saved once a consent has been successfully established to allow for reuse of existing consent in future sessions. ConsentAuthorisationApi Interface used by the PSU to authorize a consent. SessionCookie and XSRF We assume all three applications FinTeApi, ConsentAuthorisationApi, OnlineBakingApi maintain their own session information with corresponding UIs. We assume those APIs use cookies to maintain session with the corresponding user agents. In the context of this framework, those cookies are called SessionCookies. We also expect a following behavior from APIs and UserAgents: A response that sets a SessionCookie also carries a corresponding X-XSRF-TOKEN in the response header. A request that authenticates with a session cookie must also add the X-XSRF-TOKEN to the request header. RedirectSession Holds consent information for the duration of a redirect. Redirect patterns are described below . BankingProtocol Component managing access to a banking interface initiative. WE will have to deal with many protocols like NextGenPSD2, HBCI, OpenBanking UK, PolishAPI. BankingProtocolSelector Help select a banking protocol. Aspsp Data Center Data center environment of the ASPSP ASPSP Account Servicing Payment Service Providers provide and maintain a payment account for a payer as defined by the PSRs and, in the context of the Open Banking Ecosystem are entities that publish Read/Write APIs to permit, with customer consent, payments initiated by third party providers and/or make their customers\u2019 account transaction data available to third party providers via their API end points. AspspBankingApi Api banking provided by ASPSP. This interface is not directly accessed by the PSU but by the TppBankingApi. TppBankingApi will use a TppContext to authenticate with the TppBankingApi. TppContext Information used to identify the Tpp application in the ASPSP environment. Like a TPP QWAC certificate. TppConsentSession Storage for consent data in the realm of the BankingProtocol. The banking protocol is both accessible to the TppBankingApi and the ConsentAuthorizationApi. The cryptographic key needed to recover the TppConsentSession is always delivered by the calling layer. These are: - FinTechUI -> FinTechApi -> TppBankingApi -> BankingProtocol : in this case the key needed to recover the TppConsentSession in contained in the PsuConsentSession. Generally that key will transitively originate from an interaction with the user agent. - CosentAuthorizationUI -> CosentAuthorizationApi -> BankingProtocol : in this case the key needed to recover the TppConsentSession originate from the ConsentAuthSessionCookie. Beside consent data, additional data might be held in the TppConsentSession: - FinTechContext : Data needed to authorize the FinTechApi (FinTechSSLCertificate, ApiKey, SignedJWT) - Additional information needed for interaction between TPP and ASPSP but without any concern to the PSU. OnlineBankingApi Generally the online banking application on an ASPSP. In redirect cases, the ASPSP OnlineBankingApi establishes a direct session with the PSU to allow the PSU to identify himself, review and authorize the consent. OnlineBankingConsentSessionCookie This is a Cookie used to maintain the session between the OnlineBankingUI and the OnlineBankingApi. As a recommendation, the validity of this Cookie shall be limited to the life span of the consent session. As the OnlineBankingApi redirects the PSU back to the ConsentAuthorisationApi up on completion of the consent session. Redirection happens independently on whether the consent was authorized or not. OnlineBanking2ConsentAuthRedirectInfoPage It is recommended to inform the PSU prior to redirecting the PSU back to the TPP. This UI-Panel will be called OnlineBanking2ConsentAuthRedirectInfoPage. If the ASPSP is using a trusted environment (Native App) and wants to keep the relationship to the PSU alive, it is necessary to store this relationship in a separated OnlineBankingLoginSessionCookie. OnlineBankingLoginSessionCookie This Cookie will be used by the ASPSP to keep a login session of the PSU over the life span of consent session. This will prevent the PSU from performing the login step for upcoming consent sessions. TPP A TPP is a Third Party Provider - a legal entity that holds a TPP License provided by NCA (PISP, AISP etc). and operates with corresponding QWAC Certificate. TPP may serve FinTech companies with XS2A Services.","title":"Dictionary"},{"location":"architecture/dictionary/#dictionary","text":"AisConsentSpec App ASPSP AspspBankingApi BankDescriptor BankingProtocolSelector BankingProtocol BankProfile ConsentAuthorisationApi ConsentAuthorisationUI ConsentData Dictionary FinTech FinTechApi FinTechContext FinTechDC FinTechUI Information OnlineBanking2ConsentAuthRedirectInfoPage OnlineBankingApi OnlineBankingConsentSessionCookie OnlineBankingLoginSessionCookie OnlineBankingUI PSU PsuConsentSession PsuIdentifier PsuUserAgent PsuUserDevice RedirectSession SessionCookie Sharing TppBankingApi TppBankSearchApi TppConsentSession TppContext TPP UserAgentContext WebBrowser","title":"Dictionary"},{"location":"architecture/dictionary/#redirection-and-data-sharing","text":"We assume all three applications FinTechApi, ConsentAuthorisationApi, OnlineBankingApi are hosted on different domains. This is, we are not expecting Cookies set by one application to be visible to another application (this might still happen on some local development environment, where everything runs on localhost). We also do not advice adding persistent information to RedirectUrl , as these are log files everywhere on infrastructure components in data centers. RedirectUrl shall instead carry OneTime and ShortLived authorization code we call code , that can be used to retrieved shared payload through an authenticated back channel connection. This is the practice borrowed from oAuth2 RFC6749 . Following table shows defined redirects and corresponding back chanel endpoints. Origin Application Redirecting Application Response Code; Location ; AuthCodeParam; Expiration Redirect Target Application Destination Application Data EndPoint at Origin Application TppBankingApi FinTechApi 302 ; /auth ; code ; 5s ConsentAuthorisationApi ConsentAuthorisationApi /loadTppConsentSession ConsentAuthorisationApi ConsentAuthorisationApi Proprietary banking API. Assume RFC6749. /auth OnlineBankingApi OnlineBankingApi none OnlineBankingApi OnlineBankingApi 302 ; [/ok|/nok] ; code ; 5s ConsentAuthorisationApi ConsentAuthorisationApi /token ConsentAuthorisationApi ConsentAuthorisationApi 302 ; [/ok|/nok] ; code ; 5s FinTechApi TppBankingApi /loadTppConsentSession","title":"Redirection and Data Sharing"},{"location":"architecture/dictionary/#keeping-session-information","text":"We assume all three applications FinTechApi, ConsentAuthorisationApi, OnlineBankingApi maintain their own session information. This framework uses following terms to name the session information held by an application on the UserAgent of the PSU. Application SessionCookie FinTechApi Psu2FintechLoginSession ConsentAuthorisationApi ConsentAuthSessionCookie OnlineBankingApi OnlineBankingConsentSessionCookie Session information can also be kept across redirect life cycles. Upon redirecting the UserAgent to another application, the redirecting application can set Cookies that will be resent to the domain with future requests. This way, there will be no need to maintain user session information in temporary databases on the server, thus keeping server tiny.","title":"Keeping Session Information"},{"location":"architecture/dictionary/#redirectsession","text":"Holds consent information for the duration of a redirect. Redirect patterns are described below .","title":" RedirectSession"},{"location":"architecture/framework-security/","text":"End to End Perspective on PSU Data Protection Standard Use Case Session Fixation","title":"End to End Perspective on PSU Data Protection"},{"location":"architecture/framework-security/#end-to-end-perspective-on-psu-data-protection","text":"","title":"End to End Perspective on PSU Data Protection"},{"location":"architecture/framework-security/#standard-use-case","text":"","title":"Standard Use Case"},{"location":"architecture/framework-security/#session-fixation","text":"","title":"Session Fixation"},{"location":"architecture/technical-details/","text":"Technical description Layered architecture Application uses layered architecture that is composed of: REST API layer (Banking, Consent, Authentication). Responsible for consuming requests from external services. Protocol Facade. Responsible for protocol selection to serve the request, protocol result processing and encryption. Protocol layer. Modular layer that contains protocol implementation. Protocol is responsible to execute actual requests to ASPSP. The following picture represents them in graphical form: Bottom-up layers communication Application request-response flow uses message like pattern - on each layer resulting outcome is translated to the message(dto) that is native for current layer. This diagram shows the entire flow (idealized) from the protocol internals to endpoint output: Such flow allows application to perform dialog between PSU, FinTech and underlying protocol. In the essence, everything is based on the loop of 202 response codes indicating that PSU needs to be redirected somewhere to input some parameters. When 202 loop ends - user is redirected back to the FinTech and FinTech can read the account list - the presence of account list will be indicated by response code 200. Output class designation Layer (bottom-up) Output class Used for XS2A protocol API SuccessResult Return response from protocol containing a useful payload i.e. Account list XS2A protocol API ErrorResult Error result that should be reported by redirecting the user somewhere XS2A protocol API ValidationErrorResult Notify that some input is required from user and user should be redirected to the page where he can input missing data XS2A protocol API ConsentAcquiredResult Notify that consent was acquired and user should be redirected somewhere XS2A protocol API AuthorizationRequiredResult Notify that consent was missing and to get new consent PSU authorization is required XS2A protocol API AuthorizationDeniedResult During consent authorization either user or 3rd party decided to deny consent Protocol facade FacadeSuccessResult Response with useful payload (i.e. users' account list) Protocol facade FacadeErrorResult Fatal error result, no redirect possible Protocol facade FacadeStartAuthorizationResult Consent missing and authorization session to perform new consent authorization was created Protocol facade FacadeRedirectResult PSU (or FinTech is required to provide PSU and redirect him) required to be redirected somewhere Protocol facade FacadeRedirectErrorResult Some error has happened, but the redirection is required to handle it API Response entity, code 200 Response with useful payload API Response entity, code 202 Redirection is required API Response entity, code 3xx Automatic web browser redirection For example, the one of the commonly observed pattern for AIS list accounts service will be: FinTech calls OpenBanking REST API listAccounts endpoint The request is propagated to XS2A protocol XS2A protocol deduces that consent is missing and replies with AuthorizationRequiredResult or ValidationErrorResult The outcome of XS2A protocol is translated to 202 accepted-redirection for consent authorization FinTech receives 202 accepted with Location header pointing where it needs to bring PSU PSU enters consent authorization UI PSU provides the required parameters Protocol responds with ValidationErrorResult to users' input User is being redirected to next parameter input page using 202 accepted-redirection User provides more parameters Protocol responds with ConsentAcquired or Redirect result User is being redirected back to FinTech FinTech calls OpenBanking REST API listAccounts endpoint The request is propagated to XS2A protocol XS2A protocol calls the ASPSP and gets account list, returns SuccessResult Fintech receives Response entity with status code 200 and account list","title":"Technical description"},{"location":"architecture/technical-details/#technical-description","text":"","title":"Technical description"},{"location":"architecture/technical-details/#layered-architecture","text":"Application uses layered architecture that is composed of: REST API layer (Banking, Consent, Authentication). Responsible for consuming requests from external services. Protocol Facade. Responsible for protocol selection to serve the request, protocol result processing and encryption. Protocol layer. Modular layer that contains protocol implementation. Protocol is responsible to execute actual requests to ASPSP. The following picture represents them in graphical form:","title":"Layered architecture"},{"location":"architecture/technical-details/#bottom-up-layers-communication","text":"Application request-response flow uses message like pattern - on each layer resulting outcome is translated to the message(dto) that is native for current layer. This diagram shows the entire flow (idealized) from the protocol internals to endpoint output: Such flow allows application to perform dialog between PSU, FinTech and underlying protocol. In the essence, everything is based on the loop of 202 response codes indicating that PSU needs to be redirected somewhere to input some parameters. When 202 loop ends - user is redirected back to the FinTech and FinTech can read the account list - the presence of account list will be indicated by response code 200. Output class designation Layer (bottom-up) Output class Used for XS2A protocol API SuccessResult Return response from protocol containing a useful payload i.e. Account list XS2A protocol API ErrorResult Error result that should be reported by redirecting the user somewhere XS2A protocol API ValidationErrorResult Notify that some input is required from user and user should be redirected to the page where he can input missing data XS2A protocol API ConsentAcquiredResult Notify that consent was acquired and user should be redirected somewhere XS2A protocol API AuthorizationRequiredResult Notify that consent was missing and to get new consent PSU authorization is required XS2A protocol API AuthorizationDeniedResult During consent authorization either user or 3rd party decided to deny consent Protocol facade FacadeSuccessResult Response with useful payload (i.e. users' account list) Protocol facade FacadeErrorResult Fatal error result, no redirect possible Protocol facade FacadeStartAuthorizationResult Consent missing and authorization session to perform new consent authorization was created Protocol facade FacadeRedirectResult PSU (or FinTech is required to provide PSU and redirect him) required to be redirected somewhere Protocol facade FacadeRedirectErrorResult Some error has happened, but the redirection is required to handle it API Response entity, code 200 Response with useful payload API Response entity, code 202 Redirection is required API Response entity, code 3xx Automatic web browser redirection For example, the one of the commonly observed pattern for AIS list accounts service will be: FinTech calls OpenBanking REST API listAccounts endpoint The request is propagated to XS2A protocol XS2A protocol deduces that consent is missing and replies with AuthorizationRequiredResult or ValidationErrorResult The outcome of XS2A protocol is translated to 202 accepted-redirection for consent authorization FinTech receives 202 accepted with Location header pointing where it needs to bring PSU PSU enters consent authorization UI PSU provides the required parameters Protocol responds with ValidationErrorResult to users' input User is being redirected to next parameter input page using 202 accepted-redirection User provides more parameters Protocol responds with ConsentAcquired or Redirect result User is being redirected back to FinTech FinTech calls OpenBanking REST API listAccounts endpoint The request is propagated to XS2A protocol XS2A protocol calls the ASPSP and gets account list, returns SuccessResult Fintech receives Response entity with status code 200 and account list","title":"Bottom-up layers communication"},{"location":"architecture/use_cases/","text":"Use Cases Login with FinTech Application Search Bank Select Bank List of Accounts List of Transactions Redirect to Consent Authorization API Authorize Consent Redirect Approach Authorize Consent Embedded Approach Consume Service","title":"Use cases"},{"location":"architecture/use_cases/#use-cases","text":"Login with FinTech Application Search Bank Select Bank List of Accounts List of Transactions Redirect to Consent Authorization API Authorize Consent Redirect Approach Authorize Consent Embedded Approach Consume Service","title":"Use Cases"},{"location":"architecture/building_blocks/01.Application_context/","text":"Application Context Diagram Description This diagram describes the parties that are involved into services related to Open Banking Gateway. Detailed descrition of Use Cases can be found in the corresponding documentation . End User End customer that uses services of FinTech. He owns one or several bank accounts. Access to these accounts is used by FinTech to provide services. See also PSU FinTech Service An organisation (normally non-banking or neo-banking company) that acts on financial market to serve End customers with modern financial services. See also FinTech Open Banking Gateway Technical product that allows FinTech to access XS2A Services in order to fulfill demands of End-Customers. Authorises access to Bank account through direct communication with End User. It is operated by legal entity that owns TPP License or uses TPP License of FinTech. See also TPP Bank A credit or e-money institution that provides payment services and account management services. It provides XS2A Services according to PSD2 and other Open Banking initiatives. See also ASPSP","title":"Application context"},{"location":"architecture/building_blocks/01.Application_context/#application-context","text":"","title":"Application Context"},{"location":"architecture/building_blocks/01.Application_context/#diagram","text":"","title":"Diagram"},{"location":"architecture/building_blocks/01.Application_context/#description","text":"This diagram describes the parties that are involved into services related to Open Banking Gateway. Detailed descrition of Use Cases can be found in the corresponding documentation .","title":"Description"},{"location":"architecture/building_blocks/01.Application_context/#end-user","text":"End customer that uses services of FinTech. He owns one or several bank accounts. Access to these accounts is used by FinTech to provide services. See also PSU","title":"End User"},{"location":"architecture/building_blocks/01.Application_context/#fintech-service","text":"An organisation (normally non-banking or neo-banking company) that acts on financial market to serve End customers with modern financial services. See also FinTech","title":"FinTech Service"},{"location":"architecture/building_blocks/01.Application_context/#open-banking-gateway","text":"Technical product that allows FinTech to access XS2A Services in order to fulfill demands of End-Customers. Authorises access to Bank account through direct communication with End User. It is operated by legal entity that owns TPP License or uses TPP License of FinTech. See also TPP","title":"Open Banking Gateway"},{"location":"architecture/building_blocks/01.Application_context/#bank","text":"A credit or e-money institution that provides payment services and account management services. It provides XS2A Services according to PSD2 and other Open Banking initiatives. See also ASPSP","title":"Bank"},{"location":"architecture/building_blocks/02.Component_diagrams/","text":"Component diagrams Whitebox overall system Description Whitebox BankingProtocol Description","title":"Component diagrams"},{"location":"architecture/building_blocks/02.Component_diagrams/#component-diagrams","text":"","title":"Component diagrams"},{"location":"architecture/building_blocks/02.Component_diagrams/#whitebox-overall-system","text":"","title":"Whitebox overall system"},{"location":"architecture/building_blocks/02.Component_diagrams/#description","text":"","title":"Description"},{"location":"architecture/building_blocks/02.Component_diagrams/#whitebox-bankingprotocol","text":"","title":"Whitebox BankingProtocol"},{"location":"architecture/building_blocks/02.Component_diagrams/#description_1","text":"","title":"Description"},{"location":"architecture/concepts/fundamentals-of-redirect/","text":"Fundamental of User Agent Redirection Advanced use Cases The experience realized with sharing identity in online business interaction has lead to an attempt to share even more data and functionality. Many online business platform initiatives are reusing the experience made over the last decade with oAuth, OpenId Connect and other Identity Sharing schemes to define more advanced authorization frameworks that enable the sharing of other data and service on behalf of an end user. In most OpenBanking approaches evolving out there, a banking customer can authorize the custodian of his bank account (the bank) to open some functionalities to third parties. This way a third party provider of online services might pull the list of transactions of the end user's bank account or even initiate a payment on behalf of that end user. The way a banking user give his consent to the bank is very similar to the way an online use allow the IDP to share his identity with a relying party. As these authorization frameworks are reaching the banking industry, there is an imminent need of providing a very clear understanding of how they work, so we can reduce the number of erroneous implementation on the market. A there will be a bigger incentive for malicious parties to try to exploit weaknesses associated with the implementation of those authorization frameworks. Fundamental of a Redirect The purpose of this work is therefore to enlighten mechanism used in the process of redirecting a PSU from one user agent to another one. HTTP vs. XHR Redirect The HTTP protocol was originally designed to support simple hypertext content production. In this context, necessary intelligence was delegated to the container displaying the produced content. This is the reason why a web browser processing a http response for display will follow 30x responses and proceed with another request to the provided location. Using javascript to build more interactive browser applications, the XHR protocol was developed as an additional request response protocol between a web browser and a web server. With XHR, redirection is a little more complicated, as the Browser-Api still follows the redirect, but do not display the response in the browser window. Off course the javascript framework used will help read and display the response. But the redirect URL exposed with xhr.responseURL will not contain all original redirect parameters. See atomic-http-redirect-handling for details on why underlying browser APIs adopt this behavior. Beyond web browser, native application are known to have full access on the HTTP Request/Response object. Corresponding HTTP client implementation expose more detailed API that allow to control the behavior of the redirect request. This, we will model the behavior of a redirect in API taking in consideration constraints of browser implementations and ignoring the existence of native applications, knowing that the will be able to provide the behavior expected from browser implementations. Based on the facts described above, there is 2 options to choose from while implementing a redirect: - Given Full Control to User Agent : if we want the user agent to have full control on the redirect process, we will have to return a 20x and a Location response to the user agent and instruct the user agent to proceed to the provided location url. This approach will not work for non javascript enhanced browser based user agents. - Preventing Browser Based Agent from accessing URL params : Exposing url params to browser based user agents might open room for cros side scripting. If the framework is intending to add any sort of secret information to the URL, return a 30x and Location will be the best alternative as native browser API will follow the redirect before returning final response to the UserAGent. User Experience Guide require a user to be notified prior to redirecting the user to another domain. This step shall generally be done in a proper step (rather than abandoned to the UI). By presenting a redirect-info-page to the user, following action can be design to simplify the implementation of the redirect request. E.g.: the redirect info page will offer a confirmation to the user and user a simple HTTP request (no XHR) to trigger the redirect process. Response Code Option Advanced API design can allow the UI to decide if the redirect response has to be controlled by a 20x or a 30x response code. Redirect for Consent Authorization of Banking Services In OpenBanking initiatives, redirection is generally used to send a payment service user (PSU) to the TPP site, where TPP can authorize the execution of a banking service. In some situation, a TPP will even redirect the PSU to the banking site, so the PSU can interact directly with his bank for the consent authorization. In addition to using those three interfaces, the PSU might sometimes have to be redirected by the TPP or by his bank to the PSU mobile device to collect some OTPs. The following picture shows the PSU interfaces with all FinTech, TPP and Bank. Without redirection, PSU will have to manually provide authorization to each party, in the worse case, physically, having to go to the bank or third party's agency location. With redirection, we gain in speed and usability, but care has to be taken no to provide room for impersonation of the PSU. The purpose of this section is describe steps necessary to perform redirection without risk of impersonating the PSU. In the analysis, we identified two types of redirections: - API redirection, where the RedirectUrl directly points to a server API - UI redirection, where the redirect link either starts a native application on the user device of load the UI files from the designated content server. In all cases, we assume that UI file servers do not share the same domain (origin) as their corresponding API server. This is, we do not expect UI file servers to receive/process cookies set by API servers. The following picture displays 4 possible scenarios. All 4 scenarios implement the same process of a redirect from a FinTech application to a TPP application for having the PSU authorizing a banking service, and a redirect back from the TPP to the FinTech with a confirmation code. Theoretically none of those redirects can ever be protected, as there can't be any deterministic assumption on the nature and the state of the user device. Even when there is knowledge on the nature of a user device, it is difficult to determine the current state of the device. We can't know if a user mistakenly installed a malware on his device. Step-1 Service Request The process always starts with a banking service request of the PSU. This is represented on all 4 alternatives by arrow 1 a( x,c ) and arrow 1 b( s ) , where by:. - c is the session cookie between the FinTechUI and the FinTechApi. This is, we assume that the FinTechApi identified the PSU with (psu-id@fintech). - x is the XSRF-Token parameter used to protect the cookie again XSRF. - s is the state parameter generated by the FinTech and intended to be used to protect any future redirect cookie. Step-2 Redirect to TPP As the TPP maintains and manages consents previously provided by the PSU, the TPP will check for the existence of a suitable consent upon reception of the banking service request. IF there is no consent, the instruct the FinTech to redirect the PSU to the TPP consent authorization interface. This procedure contains following steps: Initiation: Arrow 2 a( s,i ) This step is necessary to avoid associating critical parameter with the redirect request. This initiation request carries - i : an identifier of the redirect session. This same identifier will be associated to the redirect url used to send the PSU to the consent authorization interface of the TPP. - s is the state parameter generated by the FinTech and intended to be used to protect any future redirect cookie. This state parameter will be associated with the back redirect url by the TPP while redirecting the PSU to the UI of the FinTech. This redirect step will contain any additional information associated with the service request to be authorized. Instruction to Redirect: Arrow 2 b( s,i ) In this step, the TPP instructs the TPP to redirect the PSU to the consent authorization interface of the TPP. This instruction contains 2 main information of interest: - i : the identifier of the redirect session. This same identifier will be associated to the redirect url used to send the PSU to the consent authorization interface of the TPP. - s is the state to be used by the FinTech to protect the redirect cookie. Instruction to Redirect: Arrow 2 c( r,i ) In this step, the FinTechApi instructs the FinTechUI to redirect the PSU to the consent authorization interface of the TPP. As we discussed above, the way we redirect we strongly depend on the nature of the user interface. For simplicity, we will assume that the FinTechUI has access to the redirect response and can protect access to the RedirectCookie. This Arrow has following information of interest: - r : This cookie is to be stored by the FinTechUI and returned to the FinTechApi with the back redirect request. - i : the identifier of the redirect session. Will be part of the redirect url. Depending on the client technology, this can be either a path or a query parameter. It is safer to make this path parameter as this wont be striped away by some user agent container. See atomic-http-redirect-handling . Instruction to Redirect: Arrows 2 d( i ) , 2 e( i ) For simplicity, we assumed that the TPP-UI (EMbeddedConsentUI) is running in a web browser. This is, the FinTechUI instructs it container (either the web browser or the operating environment) to open the TPP-UI on the user device. Step-3 Authorize Consent Authorize Service Request: Arrow 3 a..y The previous step is followed by the TPP interacting with the PSU to authorize the service requested. The TPP starts by using the redirect identifier to retrieve request details. Assuming we are dealing with an embedded SCA, the TPP will prepare and display service details to the PSU and interact with the PSU to allow the PSU to authorize the service execution (consent). In the process of the authorization, the PSU is identified as psu-id@tpp that in our case is equivalent to psu-id@aspsp as the consent occurred over the embedded TPP interface. Confirmation Code: Arrow 3 z( a ) Once the service request is authorized, the ASPSP online banking interface can return an authorization code to the TPP ( a ). This authorization code must be brought by the TPP in a subsequent step to confirm execution of the service request. Step-4 Redirect to FinTech Once authorization is performed, the TPP will have to return control to the FinTech by redirecting the the PSU to the FinTechUI. This redirection step is essential as we have to: - make sure control is given back to the same PSU that authorized the consent on the TPP interface ( psu-id@tpp ), - make sure that PSU is the same natural person that originally initiated the service request on the FinTech interface ( psu-id@fintech ). This is what we call the identity equivalence psu-id@aspsp ==> psu-id@tpp ==> psu-id@fintech . Upon verification of this identity equivalence, a confirmation call can be sent to the TPP banking interface to trigger execution of the service request. Instruction to Redirect: Arrow 4 a( s,a ) In the first step, the TPP authorization interface instruct the user agent to redirect the PSU back to the FinTechUI. In all 4 use cases, the redirect request carries both: - s : state parameter used to validate the RedirectCookie at the FinTechApi interface - a : the authorization code needed to issue a confirmation call to the TPP banking interface. Alt-1: API Redirect and In-Browser The next step depends strongly on whether the back redirect is addressed to the FinTechApi or to the FinTechUI. If the back redirect is addressed to the FinTechApi, this request will have to be performed by the user agent hosting the TPP-UI. Independent on the nature of the FinTechUI, we want the TppBankingApi to received the RedirectCookie returned with the original RedirectResponse. This will be the case if the FinTechUi is run by the same web browser as the EmbeddedConsentUI. This is why we have the arrow 4 b( s,a,r ) . This is why this arrow carries: - s : state parameter used to validate the RedirectCookie at the FinTechApi interface - a : the authorization code needed to issue a confirmation call to the TPP banking interface. - r : the redirect cookie, sent to the FinTechApi in this step because it is held by the common browser instance. In this alternative, the FinTechApi will have to use an additional redirect step to present the FinTechUI to the PSU. This is represented by the arrows 4 c( x,c ) , 4 d( x ) , 4 e( x ) and 4 f( x,c ) Upon receiving the request 4 b( s,a,r ) , the FinTechApi uses the state s to validate the contained RedirectCookie and creates a new session cookie c and corresponding XSRF-Token x that are both used to launch the FinTechUI using arrow 4 c( x,c ) . The web browser receiving the launch instruction will store the new session cookie, and use the provided redirect url containing the state parameter to load FinTechUi. The FinTechUI will finally parse the XSRF-Parameter from the loading request and use it to issue the confirmation call to the FinTechApi: 4 f( x,c ) . Alt-2: API Redirect and Browser to NativeApp If redirecting back to the FinTechApi the FinTechUI holding the cookie is a native application, there will be no automatic transfer of the RedirectCookie to the FinTechApi. In this case the arrow 4 b( s,a ) will not have r . This arrow will carry only: - s : state parameter used to validate the RedirectCookie at the FinTechApi interface - a : the authorization code needed to issue a confirmation call to the TPP banking interface. In this alternative, the FinTechApi will have to use an additional redirect step to launch the FinTechUI native application to the PSU device. This is represented by the arrows 4 c..e( x,c ) . The launch URL will have to contain both s and a . Remark that there is no way to protect the integrity of these parameters. Using arrow 4 e( s,a ) will deep link into the FinTechUi App that will parse those parameters and use them to send the confirmation request to the FinTechApi using arrow 4 f( s,a,r ) where: - s : state parameter used to validate the RedirectCookie at the FinTechApi interface - a : the authorization code needed to issue a confirmation call to the TPP banking interface. - r : the redirect cookie, stored by the FinTechUI while processing the original redirect to the TPP. Alt-3: UI Redirect and In-Browser Like described in Alt-1, the back redirect request is a response to the web browser running the TPP-UI. This browser uses the arrow 4 b,c( s,a ) to load the UI-Files (off course without the RedirectCookie). UI-Files will parse both s and a from the url and use them in arrow 4 d( s,a,r ) to issue the confirmation call to the FinTechApi. Alt-4: UI Redirect and Browser to NativeApp As launcher of FinTechUI NativeApp is on the user device, the browser running the TPP-UI will use the the arrow 4 b( s,a ) to instruct the user device to start the FinTechUI. The user device will use the arrow 4 c( s,a ) to deep link into the FinTechUi App that will parse those parameters and use them to send the confirmation request to the FinTechApi using arrow 4 d( s,a,r ) where: - s : state parameter used to validate the RedirectCookie at the FinTechApi interface - a : the authorization code needed to issue a confirmation call to the TPP banking interface. - r : the redirect cookie, stored by the FinTechUI while processing the original redirect to the TPP. API vs. UI-Redirect The redirect alternative to choose API (Alt-1 & Alt-2) vs. UI (Alt-3 & Alt-4) is dependent on the architecture of the final environment. - Selecting the API redirect approach : - (-) might require the FinTechApi to turn off CORS - (-) will require two Endpoints at the FinTechAPI, the afterRedirect(4 b( s,a,r ) or 4 d( s,a )) and the afterUIReload(4 f( x,c ) or 4 f( s,a,r )). And like we see those EndPoints will have to be dealt with differently depending on whether call back is in Alt-1 or Alt-2. - Selecting the UI approach : - (-) might require the FinTechUI to turn off CORS. Although we are more confortable turning off CORS on static content files than doing this on the API interface. - (+) will simplify the FinTechApi interface by providing a single EndPoint afterRedirect(4 d( s,a,r )) for both Alt-3 and Alt-4. Confirm Service Execution: Arrows 4 g( a,i ) , 4 z( a ) The confirmation step is initiated after the FinTech verifies the equivalence between psu-id@tpp and psu-id@fintech. This is executed by using arrow 4 g( a,i ) to forward a confirmation call to the TPP banking interface that will in turn use arrow 4 z( a ) to confirm execution of the service with the open banking interface of the ASPSP.","title":"Fundamental of User Agent Redirection"},{"location":"architecture/concepts/fundamentals-of-redirect/#fundamental-of-user-agent-redirection","text":"","title":"Fundamental of User Agent Redirection"},{"location":"architecture/concepts/fundamentals-of-redirect/#advanced-use-cases","text":"The experience realized with sharing identity in online business interaction has lead to an attempt to share even more data and functionality. Many online business platform initiatives are reusing the experience made over the last decade with oAuth, OpenId Connect and other Identity Sharing schemes to define more advanced authorization frameworks that enable the sharing of other data and service on behalf of an end user. In most OpenBanking approaches evolving out there, a banking customer can authorize the custodian of his bank account (the bank) to open some functionalities to third parties. This way a third party provider of online services might pull the list of transactions of the end user's bank account or even initiate a payment on behalf of that end user. The way a banking user give his consent to the bank is very similar to the way an online use allow the IDP to share his identity with a relying party. As these authorization frameworks are reaching the banking industry, there is an imminent need of providing a very clear understanding of how they work, so we can reduce the number of erroneous implementation on the market. A there will be a bigger incentive for malicious parties to try to exploit weaknesses associated with the implementation of those authorization frameworks.","title":"Advanced use Cases"},{"location":"architecture/concepts/fundamentals-of-redirect/#fundamental-of-a-redirect","text":"The purpose of this work is therefore to enlighten mechanism used in the process of redirecting a PSU from one user agent to another one.","title":"Fundamental of a Redirect"},{"location":"architecture/concepts/fundamentals-of-redirect/#http-vs-xhr-redirect","text":"The HTTP protocol was originally designed to support simple hypertext content production. In this context, necessary intelligence was delegated to the container displaying the produced content. This is the reason why a web browser processing a http response for display will follow 30x responses and proceed with another request to the provided location. Using javascript to build more interactive browser applications, the XHR protocol was developed as an additional request response protocol between a web browser and a web server. With XHR, redirection is a little more complicated, as the Browser-Api still follows the redirect, but do not display the response in the browser window. Off course the javascript framework used will help read and display the response. But the redirect URL exposed with xhr.responseURL will not contain all original redirect parameters. See atomic-http-redirect-handling for details on why underlying browser APIs adopt this behavior. Beyond web browser, native application are known to have full access on the HTTP Request/Response object. Corresponding HTTP client implementation expose more detailed API that allow to control the behavior of the redirect request. This, we will model the behavior of a redirect in API taking in consideration constraints of browser implementations and ignoring the existence of native applications, knowing that the will be able to provide the behavior expected from browser implementations. Based on the facts described above, there is 2 options to choose from while implementing a redirect: - Given Full Control to User Agent : if we want the user agent to have full control on the redirect process, we will have to return a 20x and a Location response to the user agent and instruct the user agent to proceed to the provided location url. This approach will not work for non javascript enhanced browser based user agents. - Preventing Browser Based Agent from accessing URL params : Exposing url params to browser based user agents might open room for cros side scripting. If the framework is intending to add any sort of secret information to the URL, return a 30x and Location will be the best alternative as native browser API will follow the redirect before returning final response to the UserAGent. User Experience Guide require a user to be notified prior to redirecting the user to another domain. This step shall generally be done in a proper step (rather than abandoned to the UI). By presenting a redirect-info-page to the user, following action can be design to simplify the implementation of the redirect request. E.g.: the redirect info page will offer a confirmation to the user and user a simple HTTP request (no XHR) to trigger the redirect process.","title":"HTTP vs. XHR Redirect"},{"location":"architecture/concepts/fundamentals-of-redirect/#response-code-option","text":"Advanced API design can allow the UI to decide if the redirect response has to be controlled by a 20x or a 30x response code.","title":"Response Code Option"},{"location":"architecture/concepts/fundamentals-of-redirect/#redirect-for-consent-authorization-of-banking-services","text":"In OpenBanking initiatives, redirection is generally used to send a payment service user (PSU) to the TPP site, where TPP can authorize the execution of a banking service. In some situation, a TPP will even redirect the PSU to the banking site, so the PSU can interact directly with his bank for the consent authorization. In addition to using those three interfaces, the PSU might sometimes have to be redirected by the TPP or by his bank to the PSU mobile device to collect some OTPs. The following picture shows the PSU interfaces with all FinTech, TPP and Bank. Without redirection, PSU will have to manually provide authorization to each party, in the worse case, physically, having to go to the bank or third party's agency location. With redirection, we gain in speed and usability, but care has to be taken no to provide room for impersonation of the PSU. The purpose of this section is describe steps necessary to perform redirection without risk of impersonating the PSU. In the analysis, we identified two types of redirections: - API redirection, where the RedirectUrl directly points to a server API - UI redirection, where the redirect link either starts a native application on the user device of load the UI files from the designated content server. In all cases, we assume that UI file servers do not share the same domain (origin) as their corresponding API server. This is, we do not expect UI file servers to receive/process cookies set by API servers. The following picture displays 4 possible scenarios. All 4 scenarios implement the same process of a redirect from a FinTech application to a TPP application for having the PSU authorizing a banking service, and a redirect back from the TPP to the FinTech with a confirmation code. Theoretically none of those redirects can ever be protected, as there can't be any deterministic assumption on the nature and the state of the user device. Even when there is knowledge on the nature of a user device, it is difficult to determine the current state of the device. We can't know if a user mistakenly installed a malware on his device.","title":"Redirect for Consent Authorization of Banking Services"},{"location":"architecture/concepts/fundamentals-of-redirect/#step-1-service-request","text":"The process always starts with a banking service request of the PSU. This is represented on all 4 alternatives by arrow 1 a( x,c ) and arrow 1 b( s ) , where by:. - c is the session cookie between the FinTechUI and the FinTechApi. This is, we assume that the FinTechApi identified the PSU with (psu-id@fintech). - x is the XSRF-Token parameter used to protect the cookie again XSRF. - s is the state parameter generated by the FinTech and intended to be used to protect any future redirect cookie.","title":"Step-1 Service Request"},{"location":"architecture/concepts/fundamentals-of-redirect/#step-2-redirect-to-tpp","text":"As the TPP maintains and manages consents previously provided by the PSU, the TPP will check for the existence of a suitable consent upon reception of the banking service request. IF there is no consent, the instruct the FinTech to redirect the PSU to the TPP consent authorization interface. This procedure contains following steps:","title":"Step-2 Redirect to TPP"},{"location":"architecture/concepts/fundamentals-of-redirect/#initiation-arrow-2asi","text":"This step is necessary to avoid associating critical parameter with the redirect request. This initiation request carries - i : an identifier of the redirect session. This same identifier will be associated to the redirect url used to send the PSU to the consent authorization interface of the TPP. - s is the state parameter generated by the FinTech and intended to be used to protect any future redirect cookie. This state parameter will be associated with the back redirect url by the TPP while redirecting the PSU to the UI of the FinTech. This redirect step will contain any additional information associated with the service request to be authorized.","title":"Initiation: Arrow 2a(s,i)"},{"location":"architecture/concepts/fundamentals-of-redirect/#instruction-to-redirect-arrow-2bsi","text":"In this step, the TPP instructs the TPP to redirect the PSU to the consent authorization interface of the TPP. This instruction contains 2 main information of interest: - i : the identifier of the redirect session. This same identifier will be associated to the redirect url used to send the PSU to the consent authorization interface of the TPP. - s is the state to be used by the FinTech to protect the redirect cookie.","title":"Instruction to Redirect: Arrow 2b(s,i)"},{"location":"architecture/concepts/fundamentals-of-redirect/#instruction-to-redirect-arrow-2cri","text":"In this step, the FinTechApi instructs the FinTechUI to redirect the PSU to the consent authorization interface of the TPP. As we discussed above, the way we redirect we strongly depend on the nature of the user interface. For simplicity, we will assume that the FinTechUI has access to the redirect response and can protect access to the RedirectCookie. This Arrow has following information of interest: - r : This cookie is to be stored by the FinTechUI and returned to the FinTechApi with the back redirect request. - i : the identifier of the redirect session. Will be part of the redirect url. Depending on the client technology, this can be either a path or a query parameter. It is safer to make this path parameter as this wont be striped away by some user agent container. See atomic-http-redirect-handling .","title":"Instruction to Redirect: Arrow 2c(r,i)"},{"location":"architecture/concepts/fundamentals-of-redirect/#instruction-to-redirect-arrows-2di-2ei","text":"For simplicity, we assumed that the TPP-UI (EMbeddedConsentUI) is running in a web browser. This is, the FinTechUI instructs it container (either the web browser or the operating environment) to open the TPP-UI on the user device.","title":"Instruction to Redirect: Arrows 2d(i), 2e(i)"},{"location":"architecture/concepts/fundamentals-of-redirect/#step-3-authorize-consent","text":"","title":"Step-3 Authorize Consent"},{"location":"architecture/concepts/fundamentals-of-redirect/#authorize-service-request-arrow-3ay","text":"The previous step is followed by the TPP interacting with the PSU to authorize the service requested. The TPP starts by using the redirect identifier to retrieve request details. Assuming we are dealing with an embedded SCA, the TPP will prepare and display service details to the PSU and interact with the PSU to allow the PSU to authorize the service execution (consent). In the process of the authorization, the PSU is identified as psu-id@tpp that in our case is equivalent to psu-id@aspsp as the consent occurred over the embedded TPP interface.","title":"Authorize Service Request: Arrow 3a..y"},{"location":"architecture/concepts/fundamentals-of-redirect/#confirmation-code-arrow-3za","text":"Once the service request is authorized, the ASPSP online banking interface can return an authorization code to the TPP ( a ). This authorization code must be brought by the TPP in a subsequent step to confirm execution of the service request.","title":"Confirmation Code: Arrow 3z(a)"},{"location":"architecture/concepts/fundamentals-of-redirect/#step-4-redirect-to-fintech","text":"Once authorization is performed, the TPP will have to return control to the FinTech by redirecting the the PSU to the FinTechUI. This redirection step is essential as we have to: - make sure control is given back to the same PSU that authorized the consent on the TPP interface ( psu-id@tpp ), - make sure that PSU is the same natural person that originally initiated the service request on the FinTech interface ( psu-id@fintech ). This is what we call the identity equivalence psu-id@aspsp ==> psu-id@tpp ==> psu-id@fintech . Upon verification of this identity equivalence, a confirmation call can be sent to the TPP banking interface to trigger execution of the service request.","title":"Step-4 Redirect to FinTech"},{"location":"architecture/concepts/fundamentals-of-redirect/#instruction-to-redirect-arrow-4asa","text":"In the first step, the TPP authorization interface instruct the user agent to redirect the PSU back to the FinTechUI. In all 4 use cases, the redirect request carries both: - s : state parameter used to validate the RedirectCookie at the FinTechApi interface - a : the authorization code needed to issue a confirmation call to the TPP banking interface.","title":"Instruction to Redirect: Arrow 4a(s,a)"},{"location":"architecture/concepts/fundamentals-of-redirect/#alt-1-api-redirect-and-in-browser","text":"The next step depends strongly on whether the back redirect is addressed to the FinTechApi or to the FinTechUI. If the back redirect is addressed to the FinTechApi, this request will have to be performed by the user agent hosting the TPP-UI. Independent on the nature of the FinTechUI, we want the TppBankingApi to received the RedirectCookie returned with the original RedirectResponse. This will be the case if the FinTechUi is run by the same web browser as the EmbeddedConsentUI. This is why we have the arrow 4 b( s,a,r ) . This is why this arrow carries: - s : state parameter used to validate the RedirectCookie at the FinTechApi interface - a : the authorization code needed to issue a confirmation call to the TPP banking interface. - r : the redirect cookie, sent to the FinTechApi in this step because it is held by the common browser instance. In this alternative, the FinTechApi will have to use an additional redirect step to present the FinTechUI to the PSU. This is represented by the arrows 4 c( x,c ) , 4 d( x ) , 4 e( x ) and 4 f( x,c ) Upon receiving the request 4 b( s,a,r ) , the FinTechApi uses the state s to validate the contained RedirectCookie and creates a new session cookie c and corresponding XSRF-Token x that are both used to launch the FinTechUI using arrow 4 c( x,c ) . The web browser receiving the launch instruction will store the new session cookie, and use the provided redirect url containing the state parameter to load FinTechUi. The FinTechUI will finally parse the XSRF-Parameter from the loading request and use it to issue the confirmation call to the FinTechApi: 4 f( x,c ) .","title":"Alt-1: API Redirect and In-Browser"},{"location":"architecture/concepts/fundamentals-of-redirect/#alt-2-api-redirect-and-browser-to-nativeapp","text":"If redirecting back to the FinTechApi the FinTechUI holding the cookie is a native application, there will be no automatic transfer of the RedirectCookie to the FinTechApi. In this case the arrow 4 b( s,a ) will not have r . This arrow will carry only: - s : state parameter used to validate the RedirectCookie at the FinTechApi interface - a : the authorization code needed to issue a confirmation call to the TPP banking interface. In this alternative, the FinTechApi will have to use an additional redirect step to launch the FinTechUI native application to the PSU device. This is represented by the arrows 4 c..e( x,c ) . The launch URL will have to contain both s and a . Remark that there is no way to protect the integrity of these parameters. Using arrow 4 e( s,a ) will deep link into the FinTechUi App that will parse those parameters and use them to send the confirmation request to the FinTechApi using arrow 4 f( s,a,r ) where: - s : state parameter used to validate the RedirectCookie at the FinTechApi interface - a : the authorization code needed to issue a confirmation call to the TPP banking interface. - r : the redirect cookie, stored by the FinTechUI while processing the original redirect to the TPP.","title":"Alt-2: API Redirect and Browser to NativeApp"},{"location":"architecture/concepts/fundamentals-of-redirect/#alt-3-ui-redirect-and-in-browser","text":"Like described in Alt-1, the back redirect request is a response to the web browser running the TPP-UI. This browser uses the arrow 4 b,c( s,a ) to load the UI-Files (off course without the RedirectCookie). UI-Files will parse both s and a from the url and use them in arrow 4 d( s,a,r ) to issue the confirmation call to the FinTechApi.","title":"Alt-3: UI Redirect and In-Browser"},{"location":"architecture/concepts/fundamentals-of-redirect/#alt-4-ui-redirect-and-browser-to-nativeapp","text":"As launcher of FinTechUI NativeApp is on the user device, the browser running the TPP-UI will use the the arrow 4 b( s,a ) to instruct the user device to start the FinTechUI. The user device will use the arrow 4 c( s,a ) to deep link into the FinTechUi App that will parse those parameters and use them to send the confirmation request to the FinTechApi using arrow 4 d( s,a,r ) where: - s : state parameter used to validate the RedirectCookie at the FinTechApi interface - a : the authorization code needed to issue a confirmation call to the TPP banking interface. - r : the redirect cookie, stored by the FinTechUI while processing the original redirect to the TPP.","title":"Alt-4: UI Redirect and Browser to NativeApp"},{"location":"architecture/concepts/fundamentals-of-redirect/#api-vs-ui-redirect","text":"The redirect alternative to choose API (Alt-1 & Alt-2) vs. UI (Alt-3 & Alt-4) is dependent on the architecture of the final environment. - Selecting the API redirect approach : - (-) might require the FinTechApi to turn off CORS - (-) will require two Endpoints at the FinTechAPI, the afterRedirect(4 b( s,a,r ) or 4 d( s,a )) and the afterUIReload(4 f( x,c ) or 4 f( s,a,r )). And like we see those EndPoints will have to be dealt with differently depending on whether call back is in Alt-1 or Alt-2. - Selecting the UI approach : - (-) might require the FinTechUI to turn off CORS. Although we are more confortable turning off CORS on static content files than doing this on the API interface. - (+) will simplify the FinTechApi interface by providing a single EndPoint afterRedirect(4 d( s,a,r )) for both Alt-3 and Alt-4.","title":"API vs. UI-Redirect"},{"location":"architecture/concepts/fundamentals-of-redirect/#confirm-service-execution-arrows-4gai-4za","text":"The confirmation step is initiated after the FinTech verifies the equivalence between psu-id@tpp and psu-id@fintech. This is executed by using arrow 4 g( a,i ) to forward a confirmation call to the TPP banking interface that will in turn use arrow 4 z( a ) to confirm execution of the service with the open banking interface of the ASPSP.","title":"Confirm Service Execution: Arrows 4g(a,i), 4z(a)"},{"location":"architecture/concepts/psu-device-redirection/","text":"Open Banking and the Complexity of User Agent Redirection Abstract Most Open Banking interaction patterns rely on user agent redirection (as seen in the world of identity management) to implement sharing of banking data and banking services. In some regions, sharing of online user banking access is driven by regulators mandating custodians (a.k.a. ASPSP or banks) to share access to user banking data at user's will with third party providers (See European PSD2). In some other regions, data sharing initiatives extend their scope to many other business domains such as telecommunication, health, and utilities (See Australian CDR). Although sharing data has always been practiced in banking business (see EBICS), the novelty of Open Banking lies within the capacity of ad-hoc online connectivity of business, that strives to enable data sharing without preceding time expensive offline authorization steps at the agency location of the custodian. In the case of EBICS, the bank account owner will use an offline channel to have his bank (custodian) explicitly give authorization to provide access to a designated third party. In a world dominated by real time online access to applications, authorization steps need to be taken right away and on the go. This is why the online platform business community leverages User Agent Redirection to allow for real time online connectivity and interaction between the user and many participating service providers. It is explained why another approach, Embedded SCA , is more suitable and more secure for sharing identities at least between regulated and supervised financial service providers, e.g. within Open Banking in Europe. The Challenge Independent of whether User Agent Redirection is being used for online real time identity sharing, or for more advanced authorization frameworks, it is imperative that the natural person being redirected from one application to another can express his or her free will without threat of impersonation by any means (technical, social engineering, etc.). The use of User Agent Redirection for sharing access to banking services will increase the malicious party incentive to invest more effort into exploiting loopholes. Among malicious parties we account: - Attackers having an interest in executing fraudulent banking transactions; - Companies financing malicious operations with the intention of illegally accessing banking transactions of competitors for industrial espionage; - Government driven cyber-attack with the purpose of gaining information on the financial behavior of citizens of the target country. Complexity of User Agent Redirection The purpose of this work is to provide insight into the complexity associated with a secure implementation of User Agent Redirection . Instead of narrating some proprietary use cases in Open Banking, we want to show that even the more mature, better known and intensively utilized case of identity provisioning (oAuth2) is too complex and not yet well enough thought out. The current state of implementation for Open Banking shows that neither financial institutions (known as ASPSP), nor third party providers (AISP, PISP, PIISP), are experienced enough to implement and operate solid, tamper proof User Agent Redirection based Open Banking sharing processes. Highlighting User Agent Redirection Common Terms Let's call : - APP-RP : the server application of a relying party that redirects user to an identity provider, - UI-RP : the UI application utilized to access the server application of the relying party, - APP-IDP : the server application providing the identity service, - UI-IDP : the UI application utilized to access the identity provider, - AUTOMATIC_REDIRECTION : a situation in which UI-RP automatically presents UI-IDP to the user. This generally happens when UI-RP and UI-IDP are on the same user device, - MANUAL_REDIRECTION : a situation in which UI-RP instructs the user to open UI-IDP. Even if a push notification is used to help the user activate the UI-IDP. Redirection Based Sharing of Identity An online business service provider generally uses client and server side applications to implement functionality. Whether or not the biggest part of the application is run on the client side (UI-?) or server side (APP-?), both sides are generally found in almost all online business applications. The typical design of an online business application looks like: Each server application (APP-?) presents a user agent (UI-?) to the end user. The identifier user@app-1 is utilized by APP-1 to manage the session between UI-1 and APP-1 (resp. user@app-2 for UI-2 and APP-2). The following picture shows the delegation of identity management to an identity provider. In this case, APP-1 and APP-2 delegate authentication to the same identity provider and thus share the same identity (user@idp). Each delegation process involves redirection. In order to make sure that redirection based delegation process will not lead to user impersonation, a wide part of the market has adopted the oAuth2 protocol. Nevertheless, even the most secure identity providers will not prevent poorly connected applications (relying parties) from offering space for impersonation of the end user. The next picture displays a classical oAuth2 authorization code workflow, showing how even oAuth2, if not well implemented, does not protect the end user from identity fraud. The workflow displayed above shows an identity sharing process based on oAuth2. Nothing states that both UI applications are on the same user device. In the rest of this document, we will assume AUTOMATIC_REDIRECTION when both UI-RP and UI-IDP are on the same device, and MANUAL_REDIRECTION when both are not on the same device. Automatic Redirection to the Identity Provider This is a situation in which UI-RP automatically presents UI-IDP to the user. It generally happens when both UI-RP and UI-IDP are on the same user device, even if they aren\u2019t in the same web browser instance. There are multiple technologies available to enable automatic redirection on devices. HTTP redirects (HTTP-302/-303) are utilized to automatically instruct the web browser to redirect the user to another page. HTTP accept (HTTP-202) can also be used with native mobile applications and browser based single page applications to instruct UI-RP to redirect the user to UI-IDP. iOS Universal Link and android App Links are used by the corresponding operating systems to automatically launch the target UI (either UI-RP or UI-IDP). The authorization flow starts with the relying party (RP) wanting to redirect control to the identity provider. As seen above, the source of redirection (APP-RP arrow 1) sends some information to the target (APP-IDP) of the redirection. The way information is transported highly depends on the nature of the redirection. In the case of AUTOMATIC_REDIRECTION , information transport happens in the form of URL query parameters. We must be aware that there is no way to protect information transported from a UI application to another UI application on a user device. Any of those parameters can be modified by a malicious program code running on the user device. In order to prevent modification of redirected parameters, oAuth2 must be extended with an initiation step that simplifies implementation and increases robustness of the oAuth2 protocol. This is the approach suggested in draft-ietf-oauth-par-00 . If we do not have an initialization step - and as we know there is no way to control the integrity of an information passed by one UI application to another one on a user device - some technical protection means must be used to make sure that after authorization, APP-IDP will not return control to the wrong UI application (because of modified redirect_uri). The type of protection to be implemented depends on the nature and the purpose of the information transported: The redirect_uri : Used to instruct the identity provider (IDP) on where to send the user back after authentication and authorization is done. If this information is changed on the way to the IDP, there is a risk that the IDP redirects control back to the wrong user agent. If the flow is not using an initialization step, the APP-RP will have to register the pre-configured URL-Template with APP-IDP before any redirection happens. More related security issues are described in draft-ietf-oauth-security-topics-14 . The state : Generally used to hold the state of UI-RP during a redirection process. The state can be used by UI-RP to help recover persistent information associated with the redirect process. Manual Redirection to UI-IDP Let's assume UI-IDP is a NativeApp, APP-RP suspects the identity of the user is (user@idp), then the redirection can occur by means of APP-RP instructing APP-IDP to send a push notification to UI-IDP. The user will then manually touch the notification message to open UI-IDP and identify with APP-IDP. This initiation of a MANUAL_REDIRECTION can be perceived as an initiation step as well. In contrast to automatic redirection, the presence of a suspected user@idp is necessary to discover the device on which to proceed with the authorization. A manual opening of UI-IDP does not indicate that the user is in control of both UI-RP and UI-IDP. In order to make sure the user controls both environments, it is necessary to have the user manually collect some information displayed by UI-RP and enter them in UI-IDP. We call this Device Linking . The way the information display and collection process works depends on the nature of both UI-RP and UI-IDP. - If for example UI-RP is a browser application running on a desktop computer and UI-IDP is a NativeApp running on a mobile phone, UI-IDP can provide tools for scanning a QR_CODE displayed by UI-RP. - UI-IDP might as well just request the user to enter a sequence of digits displayed by UI-RP. Again, linking devices in manual redirection cases is essential to make sure the same user is in control of both UI-IDP and UI-RP. Automatic Return of Control to the Relying Party The user utilizes UI-IDP to authenticate with APP-IDP and there is a session between UI-IDP and APP-IDP. APP-IDP must return control to the APP-RP in order for APP-RP to assert user identity (token) and proceed with the service request. In an AUTOMATIC_REDIRECTION case, where UI-IDP and UI-RP are on the same device, a technical redirect can be used to send control back to UI-RP. As described above HTPP 302/303/202, Universal Links and App Links are all means used to automatically pass control from one application to another one. As these technical methods are all URL based, URL parameters can be used to transport information from UI-IDP to UI-RP. We also mention above that there is no way to control the integrity of an information passed by one UI application to another one on a user device. The IDP generally sends two information back to RP: - The state parameter is sent back as received by the IDP and is used by UI-RP to validate that control was sent back to the very UI instance that initiated the authentication flow. - The code parameter is sent by the IDP and used by APP-RP to retrieve the authorization token. The next problem associated with an automatic redirection to UI-RP is that, if UI-IDP is a native application and UI-RP is a browser application, control might be returned to the wrong browser instance. This generally happens when the user did not start UI-RP on the system browser. Manual Return of Control to the Relying Party A manual return of control to APP-RP can happen in the back channel by having APP-IDP produce the token and send it in the back channel to APP-RP, making it the responsibility of APP-RP to activate UI-RP, as there is an active session between APP-RP and UI-RP. Securing Automatic Redirection An automatic redirection from APP-RP to APP-IDP for the purpose of collecting user authorization is associated with a lot of risks. For better illustration, let's call: - Alice: the honest owner of an IDP account, - Bob: the malicious person trying to gain control of Alice\u2019s identity, - UI-RP-Alice: the user agent utilized by Alice to access APP-RP, - UI-IDP-Alice: the user agent utilized by Alice to access APP-IDP, - UI-RP-Bob: The user agent utilized by Bob to access APP-RP. Below is a non-exhaustive list of topics of concern while using automatic redirection to authorize Alice. A more extensive list can be found in draft-ietf-oauth-security-topics-14 . Session Fixation A well known attack is having Bob start a session with the relying party (UI-RP-Bob -> APP-RP) and trick Alice into using the redirect url to start an authorization session with the identity provider (UI-IDP-Alice -> APP-IDP). Some frameworks will allow UI-RP-Bob to simply poll for completion of an authorization request and proceed forward when Alice has provided her consent (UI-IDP-Alice -consent-> APP-IDP). This highlights an obvious flaw in the authorization flow as Bob will gain control of the session as soon as Alice completes her authorization with the IDP. In order to make sure authorization being performed by Alice (UI-IDP-Alice -> APP-IDP) was really initiated by Alice (UI-RP-Alice -> APP-RP), and not by Bob (UI-RP-Bob -> APP-RP), APP-IDP has to auto redirect control to APP-RP through Alice UIs (APP-IDP -> UI-IDP-Alice -> UI-RP-Alice -> APP-RP). Such a redirection must carry an authorization code that is used by the relying party to collect the token from the identity provider in the back channel( APP-RP -authCode-> APP-IDP). This logical mistake still exists in some Open Banking protocol designs See [Cross Browser Payment Initiation Attack] (https://bitbucket.org/openid/fapi/src/master/TR-Cross_browser_payment_initiation_attack.md). Open Redirector In order for Bob to gain access to the authorization code, UI-RP-Bob needs to have modified the redirect_uri of the authorization request to include an open redirector hack (see CWE-601 ). Preventing Bob from gaining access to the authorization code boils down to making sure the redirect_uri processed by APP-IDP is sanitized. This requires the effort of both, APP-IDP and APP-RP: - If APP-RP can use an initiation step, see draft-ietf-oauth-par-00 , it can make sure the redirect_uri is sent to APP-IDP via a back channel initiation request and does not contain any malicious query parameter controlled by the UI. - If the redirect_uri has to be transported to the APP-IDP through the UI's, there is no way to prevent UI-RP-Bob from manipulating it. In this case, APP-IDP will have to : - check the redirect_uri provided with the authorization request against open redirect patterns before proceeding with the authorization, and - validate that the redirect_uri provided with the authorization request matches the redirect_uri provided with the back channel token request before issuing the token. Browser Interception Attack In order to make sure authorization process was started by UI-RP-Alice, APP-IDP will return control to APP-RP by redirecting the authorization response to APP-RP through Alice UIs (APP-IDP -> UI-IDP-Alice -> UI-RP-Alice -> APP-RP). The authorization code associated with this back redirect is used by APP-RP to recover the authentication token from APP-IDP through the back channel. Although \"APP-IDP -> UI-IDP-Alice\" and \"UI-RP-Alice -> APP-RP\" are protected by TLS, authorization code can be intercepted on the connection \"UI-IDP-Alice -> UI-RP-Alice\". This can be done by another application registered for the URL of UI-RP on Allice device (attack well explained in PKCE RFC7636 ). Authorization code can be intercepted on Alice\u2019s device by other means as we can not control the state of a client device. Binding User Agent (Counter Measure) While initiating redirection to APP-IDP, APP-RP can set a RedirectCookie with UI-RP-Alice (including the associated XSRF-Token). This RedirectCookie is physically bound to the user agent UI-RP-Alice. - If the redirection is performed using HTTP-302/-303, the XSRF protecting the RedirectCookie must be stored in the state parameter associated with the redirect_uri. - If the redirection is performed using HTTP-202, the XSRF parameter can be held in the local/session storage of UI-RP-Alice before forwarding control to UI-IDP-Alice (beware of the origin policy while keeping object in local/session storage). - Native Applications have a better control on the persistence and protection of those Cookies and XSRF-Tokens. While redirecting back from APP-IDP (APP-IDP -> UI-IDP-Alice -> UI-RP-Alice -> APP-RP), APP-RP will only accept the redirect code if UI-RP-? provides the original RedirectCookie (and corresponding XSRF parameter). With this approach, intercepting the authorization code will not help, as UI-RP-Bob will not have access to information stored by UI-RP-Alice. Despite this countermeasure, redirection still gets complicated when UI-IDP is a native application. Automatic back redirection in this case will start the system default web browser that might be different from the web browser used by Alice to start UI-RP. Alice. Malicious Relying party Bob could install a relying party (APP-RP-Bob) that can impersonate the original APP-RP to request a token on its behalf. Recall that most relying party server applications will be deployed by companies with not enough experience in application security. So stealing static configuration information like the client-secret won't be a major issue for well trained attackers. In order to prevent the malicious RP (APP-RP-Bob) from using an intercepted authorization code to obtain the token, IDP and RP can be required to implement server side PKCE RFC7636 . The advantage of PKCE over classical RP authentication information is that the client-secret (and other APP-RP credentials) are static while generated code_verifiers are dynamic and vary with each authorization request. Embedded SCA Approach Reviewing the oAuth2 Resource Owner Password Credentials Flow (ROPC) ROPC is one that allows a relying party to collect user credentials and take them directly to the token endpoint of the identity provider. From a technical perspective, this flow seems to be the simplest as it involves no redirection. From a data protection perspective, this flow discloses the password of the user to the RP, raising issues hard to deal with as we know that the user\u2019s password is not supposed to be shared with non-regulated third parties. We also assume that non-supervised RPs are not trustworthy enough to guarantee the secrecy of the end user's password. Highlighting the Open Banking Embedded Approach The European PSD2 initiative ensures that all Payment Service Providers participating in the Open Banking arena must be licensed, i.e. security audited and supervised, and it mandates Strong Customer Authentication (SCA) involving a minimum of two factors, i.e. credentials. This includes an SCA method called \"Embedded Approach\", which allows a licensed third party provider (RP) to collect user credentials (user banking password and transaction numbers) and forward them to the user's banking service provider. Just like the oAuth2 ROPC, the PSD2 embedded SCA approach allows a licensed TPP to see the password of the end user. But despite the oAuth2 ROPC, the PSD2 embedded approach mandates a second factor which is inherently bound to the transaction being authorized (or the consent being given). With the second factor as enhancement and the requirement of implementing that second factor for authentication with the bank\u2019s native online banking interface, disclosing the online banking password of the banking users only to supervised third party banking service providers (TPP) seems to be a less risky alternative than having banks and TPPs implement technical redirection based solutions they can't control. Recommendation : Mandate the Embedded SCA Approach Considering the fact that all open banking transactions implement a second factor (even for the PSU identification), having the online banking password of the PSU disclosed to licensed TPPs exposes less risk than having to mandate TPP-implementation of complex user agent redirection. Therefore, this paper recommends the mandate of ASPSP support of the Embedded SCA Approach : - as second factor is simple, well understood and applied to ASPSP's native online banking interfaces as well, - as Embedded SCA Approach will free banks from having to implement and operate user agent redirection without having gone through the experience of operating redirection based identity providers, - as Embedded SCA Approach will release TPPs from the obligation of implementing complex and error prone user agent redirection. Protecting the PSU's permanent online banking password can further be done by replacing the permanent online banking password with a time base one time password (TOTP), thus removing the residual risk of disclosing that permanent PSU's password to TPPs.","title":"Open Banking and the Complexity of User Agent Redirection"},{"location":"architecture/concepts/psu-device-redirection/#open-banking-and-the-complexity-of-user-agent-redirection","text":"","title":"Open Banking and the Complexity of User Agent Redirection"},{"location":"architecture/concepts/psu-device-redirection/#abstract","text":"Most Open Banking interaction patterns rely on user agent redirection (as seen in the world of identity management) to implement sharing of banking data and banking services. In some regions, sharing of online user banking access is driven by regulators mandating custodians (a.k.a. ASPSP or banks) to share access to user banking data at user's will with third party providers (See European PSD2). In some other regions, data sharing initiatives extend their scope to many other business domains such as telecommunication, health, and utilities (See Australian CDR). Although sharing data has always been practiced in banking business (see EBICS), the novelty of Open Banking lies within the capacity of ad-hoc online connectivity of business, that strives to enable data sharing without preceding time expensive offline authorization steps at the agency location of the custodian. In the case of EBICS, the bank account owner will use an offline channel to have his bank (custodian) explicitly give authorization to provide access to a designated third party. In a world dominated by real time online access to applications, authorization steps need to be taken right away and on the go. This is why the online platform business community leverages User Agent Redirection to allow for real time online connectivity and interaction between the user and many participating service providers. It is explained why another approach, Embedded SCA , is more suitable and more secure for sharing identities at least between regulated and supervised financial service providers, e.g. within Open Banking in Europe.","title":"Abstract"},{"location":"architecture/concepts/psu-device-redirection/#the-challenge","text":"Independent of whether User Agent Redirection is being used for online real time identity sharing, or for more advanced authorization frameworks, it is imperative that the natural person being redirected from one application to another can express his or her free will without threat of impersonation by any means (technical, social engineering, etc.). The use of User Agent Redirection for sharing access to banking services will increase the malicious party incentive to invest more effort into exploiting loopholes. Among malicious parties we account: - Attackers having an interest in executing fraudulent banking transactions; - Companies financing malicious operations with the intention of illegally accessing banking transactions of competitors for industrial espionage; - Government driven cyber-attack with the purpose of gaining information on the financial behavior of citizens of the target country.","title":"The Challenge"},{"location":"architecture/concepts/psu-device-redirection/#complexity-of-user-agent-redirection","text":"The purpose of this work is to provide insight into the complexity associated with a secure implementation of User Agent Redirection . Instead of narrating some proprietary use cases in Open Banking, we want to show that even the more mature, better known and intensively utilized case of identity provisioning (oAuth2) is too complex and not yet well enough thought out. The current state of implementation for Open Banking shows that neither financial institutions (known as ASPSP), nor third party providers (AISP, PISP, PIISP), are experienced enough to implement and operate solid, tamper proof User Agent Redirection based Open Banking sharing processes.","title":"Complexity of User Agent Redirection"},{"location":"architecture/concepts/psu-device-redirection/#highlighting-user-agent-redirection","text":"","title":"Highlighting User Agent Redirection"},{"location":"architecture/concepts/psu-device-redirection/#common-terms","text":"Let's call : - APP-RP : the server application of a relying party that redirects user to an identity provider, - UI-RP : the UI application utilized to access the server application of the relying party, - APP-IDP : the server application providing the identity service, - UI-IDP : the UI application utilized to access the identity provider, - AUTOMATIC_REDIRECTION : a situation in which UI-RP automatically presents UI-IDP to the user. This generally happens when UI-RP and UI-IDP are on the same user device, - MANUAL_REDIRECTION : a situation in which UI-RP instructs the user to open UI-IDP. Even if a push notification is used to help the user activate the UI-IDP.","title":"Common Terms"},{"location":"architecture/concepts/psu-device-redirection/#redirection-based-sharing-of-identity","text":"An online business service provider generally uses client and server side applications to implement functionality. Whether or not the biggest part of the application is run on the client side (UI-?) or server side (APP-?), both sides are generally found in almost all online business applications. The typical design of an online business application looks like: Each server application (APP-?) presents a user agent (UI-?) to the end user. The identifier user@app-1 is utilized by APP-1 to manage the session between UI-1 and APP-1 (resp. user@app-2 for UI-2 and APP-2). The following picture shows the delegation of identity management to an identity provider. In this case, APP-1 and APP-2 delegate authentication to the same identity provider and thus share the same identity (user@idp). Each delegation process involves redirection. In order to make sure that redirection based delegation process will not lead to user impersonation, a wide part of the market has adopted the oAuth2 protocol. Nevertheless, even the most secure identity providers will not prevent poorly connected applications (relying parties) from offering space for impersonation of the end user. The next picture displays a classical oAuth2 authorization code workflow, showing how even oAuth2, if not well implemented, does not protect the end user from identity fraud. The workflow displayed above shows an identity sharing process based on oAuth2. Nothing states that both UI applications are on the same user device. In the rest of this document, we will assume AUTOMATIC_REDIRECTION when both UI-RP and UI-IDP are on the same device, and MANUAL_REDIRECTION when both are not on the same device.","title":"Redirection Based Sharing of Identity"},{"location":"architecture/concepts/psu-device-redirection/#automatic-redirection-to-the-identity-provider","text":"This is a situation in which UI-RP automatically presents UI-IDP to the user. It generally happens when both UI-RP and UI-IDP are on the same user device, even if they aren\u2019t in the same web browser instance. There are multiple technologies available to enable automatic redirection on devices. HTTP redirects (HTTP-302/-303) are utilized to automatically instruct the web browser to redirect the user to another page. HTTP accept (HTTP-202) can also be used with native mobile applications and browser based single page applications to instruct UI-RP to redirect the user to UI-IDP. iOS Universal Link and android App Links are used by the corresponding operating systems to automatically launch the target UI (either UI-RP or UI-IDP). The authorization flow starts with the relying party (RP) wanting to redirect control to the identity provider. As seen above, the source of redirection (APP-RP arrow 1) sends some information to the target (APP-IDP) of the redirection. The way information is transported highly depends on the nature of the redirection. In the case of AUTOMATIC_REDIRECTION , information transport happens in the form of URL query parameters. We must be aware that there is no way to protect information transported from a UI application to another UI application on a user device. Any of those parameters can be modified by a malicious program code running on the user device. In order to prevent modification of redirected parameters, oAuth2 must be extended with an initiation step that simplifies implementation and increases robustness of the oAuth2 protocol. This is the approach suggested in draft-ietf-oauth-par-00 . If we do not have an initialization step - and as we know there is no way to control the integrity of an information passed by one UI application to another one on a user device - some technical protection means must be used to make sure that after authorization, APP-IDP will not return control to the wrong UI application (because of modified redirect_uri). The type of protection to be implemented depends on the nature and the purpose of the information transported: The redirect_uri : Used to instruct the identity provider (IDP) on where to send the user back after authentication and authorization is done. If this information is changed on the way to the IDP, there is a risk that the IDP redirects control back to the wrong user agent. If the flow is not using an initialization step, the APP-RP will have to register the pre-configured URL-Template with APP-IDP before any redirection happens. More related security issues are described in draft-ietf-oauth-security-topics-14 . The state : Generally used to hold the state of UI-RP during a redirection process. The state can be used by UI-RP to help recover persistent information associated with the redirect process.","title":"Automatic Redirection to the Identity Provider"},{"location":"architecture/concepts/psu-device-redirection/#manual-redirection-to-ui-idp","text":"Let's assume UI-IDP is a NativeApp, APP-RP suspects the identity of the user is (user@idp), then the redirection can occur by means of APP-RP instructing APP-IDP to send a push notification to UI-IDP. The user will then manually touch the notification message to open UI-IDP and identify with APP-IDP. This initiation of a MANUAL_REDIRECTION can be perceived as an initiation step as well. In contrast to automatic redirection, the presence of a suspected user@idp is necessary to discover the device on which to proceed with the authorization. A manual opening of UI-IDP does not indicate that the user is in control of both UI-RP and UI-IDP. In order to make sure the user controls both environments, it is necessary to have the user manually collect some information displayed by UI-RP and enter them in UI-IDP. We call this Device Linking . The way the information display and collection process works depends on the nature of both UI-RP and UI-IDP. - If for example UI-RP is a browser application running on a desktop computer and UI-IDP is a NativeApp running on a mobile phone, UI-IDP can provide tools for scanning a QR_CODE displayed by UI-RP. - UI-IDP might as well just request the user to enter a sequence of digits displayed by UI-RP. Again, linking devices in manual redirection cases is essential to make sure the same user is in control of both UI-IDP and UI-RP.","title":"Manual Redirection to UI-IDP"},{"location":"architecture/concepts/psu-device-redirection/#automatic-return-of-control-to-the-relying-party","text":"The user utilizes UI-IDP to authenticate with APP-IDP and there is a session between UI-IDP and APP-IDP. APP-IDP must return control to the APP-RP in order for APP-RP to assert user identity (token) and proceed with the service request. In an AUTOMATIC_REDIRECTION case, where UI-IDP and UI-RP are on the same device, a technical redirect can be used to send control back to UI-RP. As described above HTPP 302/303/202, Universal Links and App Links are all means used to automatically pass control from one application to another one. As these technical methods are all URL based, URL parameters can be used to transport information from UI-IDP to UI-RP. We also mention above that there is no way to control the integrity of an information passed by one UI application to another one on a user device. The IDP generally sends two information back to RP: - The state parameter is sent back as received by the IDP and is used by UI-RP to validate that control was sent back to the very UI instance that initiated the authentication flow. - The code parameter is sent by the IDP and used by APP-RP to retrieve the authorization token. The next problem associated with an automatic redirection to UI-RP is that, if UI-IDP is a native application and UI-RP is a browser application, control might be returned to the wrong browser instance. This generally happens when the user did not start UI-RP on the system browser.","title":"Automatic Return of Control to the Relying Party"},{"location":"architecture/concepts/psu-device-redirection/#manual-return-of-control-to-the-relying-party","text":"A manual return of control to APP-RP can happen in the back channel by having APP-IDP produce the token and send it in the back channel to APP-RP, making it the responsibility of APP-RP to activate UI-RP, as there is an active session between APP-RP and UI-RP.","title":"Manual Return of Control to the Relying Party"},{"location":"architecture/concepts/psu-device-redirection/#securing-automatic-redirection","text":"An automatic redirection from APP-RP to APP-IDP for the purpose of collecting user authorization is associated with a lot of risks. For better illustration, let's call: - Alice: the honest owner of an IDP account, - Bob: the malicious person trying to gain control of Alice\u2019s identity, - UI-RP-Alice: the user agent utilized by Alice to access APP-RP, - UI-IDP-Alice: the user agent utilized by Alice to access APP-IDP, - UI-RP-Bob: The user agent utilized by Bob to access APP-RP. Below is a non-exhaustive list of topics of concern while using automatic redirection to authorize Alice. A more extensive list can be found in draft-ietf-oauth-security-topics-14 .","title":"Securing Automatic Redirection"},{"location":"architecture/concepts/psu-device-redirection/#session-fixation","text":"A well known attack is having Bob start a session with the relying party (UI-RP-Bob -> APP-RP) and trick Alice into using the redirect url to start an authorization session with the identity provider (UI-IDP-Alice -> APP-IDP). Some frameworks will allow UI-RP-Bob to simply poll for completion of an authorization request and proceed forward when Alice has provided her consent (UI-IDP-Alice -consent-> APP-IDP). This highlights an obvious flaw in the authorization flow as Bob will gain control of the session as soon as Alice completes her authorization with the IDP. In order to make sure authorization being performed by Alice (UI-IDP-Alice -> APP-IDP) was really initiated by Alice (UI-RP-Alice -> APP-RP), and not by Bob (UI-RP-Bob -> APP-RP), APP-IDP has to auto redirect control to APP-RP through Alice UIs (APP-IDP -> UI-IDP-Alice -> UI-RP-Alice -> APP-RP). Such a redirection must carry an authorization code that is used by the relying party to collect the token from the identity provider in the back channel( APP-RP -authCode-> APP-IDP). This logical mistake still exists in some Open Banking protocol designs See [Cross Browser Payment Initiation Attack] (https://bitbucket.org/openid/fapi/src/master/TR-Cross_browser_payment_initiation_attack.md).","title":"Session Fixation"},{"location":"architecture/concepts/psu-device-redirection/#open-redirector","text":"In order for Bob to gain access to the authorization code, UI-RP-Bob needs to have modified the redirect_uri of the authorization request to include an open redirector hack (see CWE-601 ). Preventing Bob from gaining access to the authorization code boils down to making sure the redirect_uri processed by APP-IDP is sanitized. This requires the effort of both, APP-IDP and APP-RP: - If APP-RP can use an initiation step, see draft-ietf-oauth-par-00 , it can make sure the redirect_uri is sent to APP-IDP via a back channel initiation request and does not contain any malicious query parameter controlled by the UI. - If the redirect_uri has to be transported to the APP-IDP through the UI's, there is no way to prevent UI-RP-Bob from manipulating it. In this case, APP-IDP will have to : - check the redirect_uri provided with the authorization request against open redirect patterns before proceeding with the authorization, and - validate that the redirect_uri provided with the authorization request matches the redirect_uri provided with the back channel token request before issuing the token.","title":"Open Redirector"},{"location":"architecture/concepts/psu-device-redirection/#browser-interception-attack","text":"In order to make sure authorization process was started by UI-RP-Alice, APP-IDP will return control to APP-RP by redirecting the authorization response to APP-RP through Alice UIs (APP-IDP -> UI-IDP-Alice -> UI-RP-Alice -> APP-RP). The authorization code associated with this back redirect is used by APP-RP to recover the authentication token from APP-IDP through the back channel. Although \"APP-IDP -> UI-IDP-Alice\" and \"UI-RP-Alice -> APP-RP\" are protected by TLS, authorization code can be intercepted on the connection \"UI-IDP-Alice -> UI-RP-Alice\". This can be done by another application registered for the URL of UI-RP on Allice device (attack well explained in PKCE RFC7636 ). Authorization code can be intercepted on Alice\u2019s device by other means as we can not control the state of a client device.","title":"Browser Interception Attack"},{"location":"architecture/concepts/psu-device-redirection/#binding-user-agent-counter-measure","text":"While initiating redirection to APP-IDP, APP-RP can set a RedirectCookie with UI-RP-Alice (including the associated XSRF-Token). This RedirectCookie is physically bound to the user agent UI-RP-Alice. - If the redirection is performed using HTTP-302/-303, the XSRF protecting the RedirectCookie must be stored in the state parameter associated with the redirect_uri. - If the redirection is performed using HTTP-202, the XSRF parameter can be held in the local/session storage of UI-RP-Alice before forwarding control to UI-IDP-Alice (beware of the origin policy while keeping object in local/session storage). - Native Applications have a better control on the persistence and protection of those Cookies and XSRF-Tokens. While redirecting back from APP-IDP (APP-IDP -> UI-IDP-Alice -> UI-RP-Alice -> APP-RP), APP-RP will only accept the redirect code if UI-RP-? provides the original RedirectCookie (and corresponding XSRF parameter). With this approach, intercepting the authorization code will not help, as UI-RP-Bob will not have access to information stored by UI-RP-Alice. Despite this countermeasure, redirection still gets complicated when UI-IDP is a native application. Automatic back redirection in this case will start the system default web browser that might be different from the web browser used by Alice to start UI-RP. Alice.","title":"Binding User Agent (Counter Measure)"},{"location":"architecture/concepts/psu-device-redirection/#malicious-relying-party","text":"Bob could install a relying party (APP-RP-Bob) that can impersonate the original APP-RP to request a token on its behalf. Recall that most relying party server applications will be deployed by companies with not enough experience in application security. So stealing static configuration information like the client-secret won't be a major issue for well trained attackers. In order to prevent the malicious RP (APP-RP-Bob) from using an intercepted authorization code to obtain the token, IDP and RP can be required to implement server side PKCE RFC7636 . The advantage of PKCE over classical RP authentication information is that the client-secret (and other APP-RP credentials) are static while generated code_verifiers are dynamic and vary with each authorization request.","title":"Malicious Relying party"},{"location":"architecture/concepts/psu-device-redirection/#embedded-sca-approach","text":"","title":"Embedded SCA Approach"},{"location":"architecture/concepts/psu-device-redirection/#reviewing-the-oauth2-resource-owner-password-credentials-flow-ropc","text":"ROPC is one that allows a relying party to collect user credentials and take them directly to the token endpoint of the identity provider. From a technical perspective, this flow seems to be the simplest as it involves no redirection. From a data protection perspective, this flow discloses the password of the user to the RP, raising issues hard to deal with as we know that the user\u2019s password is not supposed to be shared with non-regulated third parties. We also assume that non-supervised RPs are not trustworthy enough to guarantee the secrecy of the end user's password.","title":"Reviewing the oAuth2 Resource Owner Password Credentials Flow (ROPC)"},{"location":"architecture/concepts/psu-device-redirection/#highlighting-the-open-banking-embedded-approach","text":"The European PSD2 initiative ensures that all Payment Service Providers participating in the Open Banking arena must be licensed, i.e. security audited and supervised, and it mandates Strong Customer Authentication (SCA) involving a minimum of two factors, i.e. credentials. This includes an SCA method called \"Embedded Approach\", which allows a licensed third party provider (RP) to collect user credentials (user banking password and transaction numbers) and forward them to the user's banking service provider. Just like the oAuth2 ROPC, the PSD2 embedded SCA approach allows a licensed TPP to see the password of the end user. But despite the oAuth2 ROPC, the PSD2 embedded approach mandates a second factor which is inherently bound to the transaction being authorized (or the consent being given). With the second factor as enhancement and the requirement of implementing that second factor for authentication with the bank\u2019s native online banking interface, disclosing the online banking password of the banking users only to supervised third party banking service providers (TPP) seems to be a less risky alternative than having banks and TPPs implement technical redirection based solutions they can't control.","title":"Highlighting the Open Banking Embedded Approach"},{"location":"architecture/concepts/psu-device-redirection/#recommendation-mandate-the-embedded-sca-approach","text":"Considering the fact that all open banking transactions implement a second factor (even for the PSU identification), having the online banking password of the PSU disclosed to licensed TPPs exposes less risk than having to mandate TPP-implementation of complex user agent redirection. Therefore, this paper recommends the mandate of ASPSP support of the Embedded SCA Approach : - as second factor is simple, well understood and applied to ASPSP's native online banking interfaces as well, - as Embedded SCA Approach will free banks from having to implement and operate user agent redirection without having gone through the experience of operating redirection based identity providers, - as Embedded SCA Approach will release TPPs from the obligation of implementing complex and error prone user agent redirection. Protecting the PSU's permanent online banking password can further be done by replacing the permanent online banking password with a time base one time password (TOTP), thus removing the residual risk of disclosing that permanent PSU's password to TPPs.","title":"Recommendation : Mandate the Embedded SCA Approach"},{"location":"architecture/concepts/psu-security-concept/","text":"PSU Access Security Design Abstract We define the OpenBanking PSU Contract as a relationship between the PSU , the FinTech , the TPP and the ASPSP so that: - the PSU can initiate banking/payment services through an application provided by the FinTech , and for this purpose, - the PSU can authorize the TPP to service this initiated payment/banking requests from a designated FinTech on behalf of the PSU, and for this purpose, - the PSU can authorize the ASPSP to service this initiated payment/banking requests from a designated TPP on behalf of the PSU. This is, the PSU might be interacting with up to three different legal entities to consume a single banking/payment service (FinTech, TPP and ASPSP). Therefore, the entire OpenBanking service flow involves the initiation, authorization and confirmation of the banking/payment service. The integrity of the entire service flow is only given if we can verify that: - the PSU that controls the credentials used to identify at the FinTech interface and initiate a banking/payment service at that FinTech interface is the same natural person as the PSU that controls the credential used to identify at the TPP interface for the purpose of authorizing that initiated banking service , and that - the PSU that controls the credentials used to identify at the TPP interface for the purpose of authorizing an initiated banking service is the same natural person as the PSU that controls the credentials used to identify at the ASPSP interface with the purpose of authorizing that initiated banking service at the ASPSP interface, and that - the PSU that controls the credentials used to identify at the ASPSP interface and authorize an initiated banking service is the same natural person as the PSU that finally identifies at the FinTech interface to confirm that authorized banking/payment service. We call this relation the PSU identities equivalence . This is, ensuring integrity of the overall PSU OpenBanking service flow boils down to the verification of the equivalence of involved PSU identities (psu-id@fintech ==> psu-id@tpp ==> psu-id@aspsp). Therefore, the purpose of this work is to analyze interactions to be performed between a PSU and those three legal entities while initiating, authorizing and confirming a banking/payment service, and then provide recommendations on how to secure those interactions such as to maintain the integrity of the banking service consumed. The following picture depicts participants and interfaces used in this concept. Core Participants PSU A Payment Service User is any natural person that uses a banking or payment service on behalf of himself or on behalf of another natural person or legal entity. Form the perspective of this analysis, a PSU: - is a natural person, - is in possession of some personal non sharable online banking credentials, - uses applications running on some devices to interact with online services, - can act on behalf of himself, another natural or legal person, ASPSP An Account Servicing Payment Service Provider is a legal entity maintains payment account for natural and/or legal person. Form the perspective of this analysis, an ASPSP: - might provide an online interface for use by a PSU to authorize a consent (OnlineBankingApi), - might provide an application for use by the PSU to access the OnlineBankingApi (OnlineBankingUI), - provides an online interface for use by a TPP for online access to banking services (OpenBankingApi), - might provide an online interface for use by a TPP to forward PSU consent authorization to the ASPSP (OpenBankingApi) The psu-id@aspsp is the identity of the PSU as known to the ASPSP. This identity generally matches an online banking identifier in the realm of the ASPSP. TPP A Third Party Provider is a legal entity that implements access to ASPSP OpenBanking interfaces. A TPP is a regulated entity that implements legal provisions to protect PSU banking data obtained from OpenBankingApis. Market practices show that some TPPs are setup to service other entities (FinTech) with access to banking services. Form the perspective of this analysis, a TPP: - provides an online interface for the management of PSU consents (ConsentAuthorisationApi) - provides an application for use by the PSU to authorize consent in the embedded approach (EmbeddedConsentUI). This same application can also be used to present redirect info pages to the PSU (RedirectInfoPage). - provides an online interface for use by a FinTech to access banking services (TppBankApi, TppBankSearchApi), The psu-id@tpp is the PSU as known to the TPP. If TPP environment is designed to service a single FinTech, this identity can be set equal to the psu-id@tpp . If a TPP environment services multiple FinTech entities, the TPP will have to establish a separated PSU identity that references all corresponding FinTech identities. This requirement only exists because some OpenBanking specifications do not allow TPP to maintain multiple valid consents of the same type on the same bank account. In a situation where the TPP uses the same account information consent to service many FinTech, a TPP consent management layer must allow a PSU to revoke that consent for a designated FinTech without revoking the consent at the ASPSP level. FinTech A FinTech is a legal entity that provides some sort of aggregated online banking/payment services to other natural and legal people. From the perspective of this analysis, a FinTech: - provides an online interface for use by a PSU to access banking services (FinTechApi), - provides an application for use by the PSU to consume banking services (FinTechUI, FinTechSearchUI). The psu-id@fintech is the identity of the PSU in the realm of the FinTech, as most FinTech applications require the PSU to establish an identity before using the application. This is the most important identity as it covers the consumption of the banking/payment services. Further identities (tpp, aspsp) are only needed for authorization. This framework is designed such as to request the FinTech to provide a permanent unique identity of each PSU to the TPP. PsuUserDevice A PsuUserDevice runs applications used by the PSU to access banking services. Those applications are generally called PsuUserAgents. Sample PSU user devices are Personal Computers, Mobile Phones or even SecureId Token devices. PsuUserAgent A PsuUserAgent is an application running on a PsuUserDevice and used by the PSU to access banking functionality. PsuUserAgents are either web applications running on a standard web browser or native applications. A web browser is considered compliant with this framework when : - it can protect access to cookies. - it can manage redirection as defined by the http specification. For uniformity, we require native applications considered to be compliant with this framework to provide the same behavior as a compliant web browser based PsuUgerAgent with respect to cookie management and redirection. Following specifications deal with security threads associated with the redirection between UI-Applications on a PsuUserDevice: RFC8252:OAuth 2.0 for Native Apps , RFC7636:Proof Key for Code Exchange by OAuth Public Clients . UserAgentContext Independent on the type of PsuUserAgent, OpenBanking interfaces will require transmission of a class of information associated with the PsuUserAgent so they can perform verification of the authenticity of the original PSU request and customize the response produced for intermediary layers. We group these data under the name \"UserAgentContext\". Following header names are among the UserAgentContext: IP-Address, IP-Port, Accept, Accept-Charset, Accept-Encoding, Accept-Language, Device-ID, User-Agent, Geo-Location, Http-Method. Security Considerations This work deals with details associated with the verification that the natural person that controls credentials used to authorize the initiation of a banking service at the TPP or ASPSP interface also controls credentials used to initiated that service at the FinTech interface. This is, we want to prevent the owner of some online banking credentials to involuntarily use them to authorize a banking service initiated by another natural person. Cookies The first measure consists in protecting a session established between a PsuUgerAgent and a ServerApplication (FinTechApi, ConsentAuthorizeApi). The use of Cookies RFC6265 provides the most elaborated way to protect a session established between a PsuUgerAgent and a ServerApplication. We assume a PsuUgerAgent storing a cookie fulfills following requirements: - Cookies carrying the attribute HttpOnly are not provided access to scripts run by a web browser based UserAgent. Native applications designed for banking services must undergo through security reviews to make sure they fulfill this requirement. - Cookies carrying the attribute Secure are only sent to the server over SSL connections. - Expired Cookies (attribute Expires, Max-Age ) are not sent to the server. - Cookies set with no value ( SessionCookie=; ) are deleted from the UserAgent. - Cookies shall never be transmitted to a domain not matching it origin. - In the same domain, cookies shall only be transmitted to the configured path. SessionCookie and XSRF We assume all three applications FinTeApi, ConsentAuthorisationApi, OnlineBakingApi maintain their own session information with corresponding UIs. We assume those APIs use cookies to maintain session with the corresponding PsuUserAgents. In the context of this framework, those cookies are called SessionCookies. We also expect a following behavior from APIs and UserAgents: * A response that sets a SessionCookie also carries a corresponding X-XSRF-TOKEN in the response header. * A request that authenticates with a SessionCookie must also add the X-XSRF-TOKEN to the request header. * Server must match X-XSRF-TOKEN against SessionCookie before proceeding with the request. Redirection The server can request the PsuUgerAgent to redirect the user to another application by returning an \"HTTP 302\" response code to the PsuUserAgent. The way a PsuUserAgent proceeds with a location URL depend on the nature and the configuration of the host PsuUserDevice. The handling of redirection in native applications environments is well handled in OAuth 2.0 for Native Apps RFC8252 . We will be using redirection to switch the user context from one application to another one. Following redirection will generally be found in this framework: - FinTechApi to-> ConsentAuthorisationApi - ConsentAuthorisationApi to-> OnlineBankingApi - OnlineBankingApi backTo-> ConsentAuthorisationApi - ConsentAuthorisationApi backTo-> FinTechApi We assume all three ServerApplications (FinTechApi, ConsentAuthorisationApi, OnlineBankingApi) are hosted on different domains. This is, we do not expect cookies set by one ServerApplication to be visible to another ServerApplication. We assume UiApps (OnlineBankingUI, EmbeddedConsentUI, FinTechUI/FinTechSearchUI) do not share context information. They can only interact with each other by the way of the hosting PsuUserDevice using the URL provided by the source UiApp to open the target UIApp. Redirection and XSRF As we can not protect/control redirection on user device, known internet based identity protocols like oAuth2 make use of the state parameter to store information that will be sent back to the redirection source and used by the redirection source to verify that the user was sent back to the original source UIApp. This is, implementing XSRF for redirection consists in storing a RedirectCookie in the source UIApp and adding a corresponding XSRF-Token to the state parameter. Redirection and Data Sharing We also do not advice adding too many persistent information to the redirection URL, as these are all logged in files everywhere on infrastructure components in data centers. If we have any bulky information to share between the source UIApp and the target UIApp, we can add a OneTime and ShortLived authorization code we called redirectCode to RedirectUrl . This redirectCode can be used at target to retrieved shared payload (generally through an authenticated back channel connection). This is the practice borrowed from oAuth2 RFC6749 . Identity Equivalence When a PSU initiate a banking service at the FinTech interface (FinTechApi), the processing TPP will initiate a consent authorization process if needed (TppBankingApi). Once a consent authorization process is initiated by the TppBankingApi, we want to make sure that the PSU giving his consent (psu-id@tpp, psu-id@aspsp), is the same as the PSU requesting the service at the FinTech interface (psu-id@fintech). Ensuring the equivalence of those identities can be represented as (assuming alice and bob are PSUs): alice@fintech ==> alice@tpp ==> alice@aspsp // Where alice@fintech ==> alice@tpp neans the person identified at the FinTechApi as alice@fintech controls the necessary credentials used to identify at the ConsentAuthorisationApi as alice@tpp This is, the integrity of the OpenBanking PSU Contract is broken when security breaches can be used to compromise these equivalences like in the following pseudo code: bob@fintech ==> alice@tpp ==> alice@aspsp // although in reality bob@fintech =/=> alice@tpp // In this case bob identifies with the FinTechApi (as bob@fintech) but manipulates alice to identify with the ConsentAuthorisationApi and provide her consent for the requested banking service. bob@fintech ==> bob@tpp ==> alice@aspsp // although in reality bob@tpp =/=> alice@aspsp // In this case bob identifies with the FinTechApi and the ConsentAuthorisationApi but manipulates alice to identify with the OnlieBankingApi and provide her consent for the requested banking service. Step-1: Identify PSU at the FinTechApi We always expect the PSU to be identified at the FinTechApi interface. So we assume that the psu-id@fintech is known. The integrity of the rest of the contract relies on the capability of the FinTech to protect the session associating the PSU to the FinTechApi. The service request itself is always initiated by the FinTechApi. Before initiation, we assume that the PSU (alice) has signed into the FinTechApi and her identity is known to the FinTechApi and thus associated with the service request forwarded to the TppBankingApi. Step-2: Store psu-id@fintech with the ConsentAuthorizationSession While processing a service request, if the TPP notices that the service request is not covered by a consent (either as a result of pre-checking for the consent or from an error returned by the ASPSP's OpenBankingApi), the TPP will trigger a new consent authorization process identifies by an auth-id and called ConsentAuthorizationSession . Starting a new ConsentAuthorizationSession, we require the TPP to store the FinTech identity of the service requesting PSU alice@fintech with the ConsentAuthorizationSession record before initiating a redirect to the ConsentAuthorisationApi. This is, the ConsentAuthorizationSession record stored in the TPP Database has the state: // Syntax: [index+]=ConsentAuthorizationSession[data] [auth-id,redirectCode]=ConsentAuthorizationSession[auth-id,redirectCode, alice@fintech, ConsentData] // Where redirectCode is a one time key that can be used by the ConsentAuthorisationApi once to retrieve the ConsentAuthorizationSession. // Where auth-id is the identifier of this ConsentAuthorizationSession Step-2: Identify PSU at the TPP ConsentAuthorisationApi At first, redirecting a PSU from the FinTechApi to the TPP ConsentAuthorisationApi does not establish any relationship between the PSU and the TPP, even if we can use the redirectCode associated with the redirected URL to retrieve ConsentAuthorisationSession. Of course the ConsentAuthorisationApi knows that the ConsentAuthorizationSession was initiated by alice@fintech, but this does not mean that the PSU controlling the current PsuUserAgent (known as ConsentAuthorisationUI) is the same natural person as the one controling the identity alice@fintech. In order to proceed with the ConsentAuthorisationSession, the TPP ConsentAuthorisationApi will have to establish an identification of the natural person controlling the UserAgent, resulting in a new PSU identity called (psu-id@tpp). This PSU identity (psu-id@tpp) is associated with the ConsentAuthorisationSession upon successful authentication of the PSU at the TPP ConsentAuthorisationApi interface. At this stage, the ConsentAuthorizationSession record stored in the TPP Database has the following state: [auth-id,redirectCode]=ConsentAuthorizationSession[auth-id,redirectCode, alice@fintech, alice123@tpp, ConsentData] // But with the assumption that alice@fintech =/=> alice123@tpp. // Meaning that both identities are not yet verified equivalent (controlled by the same natural person) Even though the ConsentAuthorizationSession in the TPP database is associated with two identities (alice@fintech and alice123@tpp), there is no proof that both identities alice@fintech and alice123@tpp are controlled by the same natural person. Step-3a: ConsentAuthorisation at the TPP's ConsentAuthorisationApi (Embedded-sca) In an Embedded-SCA case, the credentials associated with psu-id@aspsp are collected by the ConsentAuthorisationApi and forwarded to the OpenBankingApi of the ASPSP. In this case it is easy to assume uniqueness between both psu-id@tpp and psu-id@aspsp as both are done within the same user session at the same interface. This results in the following record after a successful embedded consent authorization at the ConsentAuthorisationApi: [auth-id,redirectCode]=ConsentAuthorizationSession[auth-id,redirectCode, alice@fintech, alice123@tpp, alice-s@aspsp, ConsentData, alice123@tpp==>alice-s@aspsp] // Where alice@fintech =/=> alice123@tpp. // Meaning that both identities are not yet verified equivalent (owned by the same natural person) // Where alice123@tpp ==> alice-s@aspsp. // Meaning alice123@tpp could provide the banking credentials of alice-s@aspsp. Even in this embedded case, there is still a missing equivalence between alice@fintech and alice-s@tpp . Step-3b: Identify PSU at the ASPSP's OnlineBankingApi (Redirect-sca) In a Redirect-SCA case (oauth, redirect, decoupled), the PSU has to be redirected by the ConsentAuthorisationApi to the OnlienBanking interface of the ASPSP. After a successful consent authorization at the OnlienBanking interface, the record could be updated by the mean of poling the authorization status of this ConsentAuthorizationSession at the OpenBankingApi of the ASPSP. Upon successful authorization of the requested consent, the ConsentAuthorizationSession in the database of the TPP looks like: [auth-id,redirectCode]=ConsentAuthorizationSession[auth-id,redirectCode, alice@fintech, alice123@tpp, alice-s@aspsp, ConsentData] // Where alice@fintech =/=> alice123@tpp. // Meaning that both identities are not yet verified equivalent (owned by the same natural person) // Where alice123@tpp =/=> alice-s@aspsp. // Meaning that both identities are not yet verified equivalent (owned by the same natural person) Step-4: Verify Equivalence between psu-id@aspsp and psu-id@tpp (Redirect-sca) After a successful consent authorization at the OnlineBankingApi of the ASPSP, the framework has to ensure equivalence between the PSU identified at the TPP and the PSU identified at the ASPSP. In this framework, we designed a two steps redirection FinTech -> TPP -> ASPSP knowing that this might make the process more cumbersome, but this design represents the superset of most of the cases found on the market. After thorough analysis of most scenarios, we noticed that the identity equivalence process can only securely happen in one of these ways: Alt-1: Sharing of Identity Provider If two involved entities (FinTech, TPP, ASPSP) share the same identity provider (IDP), the identity association process will be simple as the IDP will provide a common identifier. For example the subject claim of an identity token could lead to the verification of subject(alice123@tpp)==subject(alice-s@aspsp). Alt-2: No Sharing of Identity Provider If two parties are not sharing identity provider, a physical back redirection from the ASPSP to the TPP must be used to help complete the identity verification. Note that a physical back redirection will not be possible with the decoupled approach. Following sub-steps will be needed to ensure clean and secure physical back redirection in the example of a redirect from the TPP to the ASPSP: Make sure the physical back redirection sends the PSU to the Source PsuUserAgent The URL for the physical back redirection must have been protected against manipulation: - In case there is an initiation step present between TPP and ASPSP, use this step must have been used to transfer the back redirection url to the ASPSP (this is an example of the redirect approach of the NextGenPSD2 API). - In case there is no such initiation step (generally when OAuth is being used), make sure oAuth2 back redirection url templates and webOrigins are properly designed, as the concrete back redirection url is transported in the redirect_uri parameter of the consent request and exposed to attackers for manipulations. Verify Redirect State once in the Source PsuUserAgent A RedirectCookie must have been set on the PsuUserAgent while redirecting a user from the TPP (ConsentAuthorisationApi) to the ASPSP (OnlineBankingApi). The back redirection url to contains contains the state parameter that is used by the source PsuUserAgent to validate stored RedirectCookie. If a physical redirect can occur from the ASPSP (OnlineBankingApi) back to the TPP (ConsentAuthorisationApi), a validation of the original RedirectCookie can be taken as a guaranty to declare equivalence between the psu-id@tpp and the psu-id@aspsp . Alt-3: No Sharing of IDP and Decoupled-sca We define a decoupled approach as one where there no way of achieving physical (back) redirection between the source UIApp and the target UiApp. This generally happens when both are not on the same physical device. In this case a physical exchange muss happen. This physical information exchange is generally sufficient in one direction as the purpose is to make sure the PSU is physically in control of both devices (and UIApp credentials). Following are among other means for physical information exchange between two devices: Manual Code Transfer Physical sharing of state information between the source an the target of the redirection can be covered by having one side of the redirect enter a redirectCode displayed by the other side. In this case the redirectCode displayed is the handle for a more complex hash code shared over the back channel between source and target of the redirect. QR-Scan Physical sharing of state information between the source an the target of the redirection can be covered by having one side of the redirect (camera capable side) the possibility to scan a QR-Code displayed by the other side UIApp. Push notifications A push notification could be used to deep link the user into the target decoupled UIApp. To prevent spam, push notification shall only be done if the overall process can provide a sufficient level of confidence that the source side of the redirection identified the PSU before the initiation of the redirection process. The use of push notification can replaces the manual code or QR-scan described above. Limitation of Identity Equivalence for Existing OpenBanking Flows In some OpenBanking approaches, validating the consent at the OnlineBanking interface of the ASPSP directly finalizes authorization of the service request. The current state of the NextGenPSD2 specification for example finalizes a payment initiation with the act of a PSU authorizing the payment consent (either on the ASPSP or TPP interface), but future release are planing an additional step for the confirmation of the service request at the OpenBanking interface (after authorization). This additional step is necessary for to complete verification of the identity equivalence as described above. Recall that this weakness is only provided if the consent authorizing interface (OnlineBankingApi for redirect-sca or ConsentAuthorizationApi for embedded-sca) can not establish identity equivalence. Remember that if source and target share the same identity provider, target will generally be able establish identity equivalence and therefore authorized payment initiation can be release for execution without breach of the OpenBanking PSU Contract .","title":"PSU Security Concept"},{"location":"architecture/concepts/psu-security-concept/#psu-access-security-design","text":"","title":"PSU Access Security Design"},{"location":"architecture/concepts/psu-security-concept/#core-participants","text":"","title":"Core Participants"},{"location":"architecture/concepts/psu-security-concept/#security-considerations","text":"This work deals with details associated with the verification that the natural person that controls credentials used to authorize the initiation of a banking service at the TPP or ASPSP interface also controls credentials used to initiated that service at the FinTech interface. This is, we want to prevent the owner of some online banking credentials to involuntarily use them to authorize a banking service initiated by another natural person.","title":"Security Considerations"},{"location":"architecture/concepts/psu-security-concept/#redirection-and-xsrf","text":"As we can not protect/control redirection on user device, known internet based identity protocols like oAuth2 make use of the state parameter to store information that will be sent back to the redirection source and used by the redirection source to verify that the user was sent back to the original source UIApp. This is, implementing XSRF for redirection consists in storing a RedirectCookie in the source UIApp and adding a corresponding XSRF-Token to the state parameter.","title":"Redirection and XSRF"},{"location":"architecture/concepts/psu-security-concept/#redirection-and-data-sharing","text":"We also do not advice adding too many persistent information to the redirection URL, as these are all logged in files everywhere on infrastructure components in data centers. If we have any bulky information to share between the source UIApp and the target UIApp, we can add a OneTime and ShortLived authorization code we called redirectCode to RedirectUrl . This redirectCode can be used at target to retrieved shared payload (generally through an authenticated back channel connection). This is the practice borrowed from oAuth2 RFC6749 .","title":"Redirection and Data Sharing"},{"location":"architecture/concepts/psu-security-concept/#step-1-identify-psu-at-the-fintechapi","text":"We always expect the PSU to be identified at the FinTechApi interface. So we assume that the psu-id@fintech is known. The integrity of the rest of the contract relies on the capability of the FinTech to protect the session associating the PSU to the FinTechApi. The service request itself is always initiated by the FinTechApi. Before initiation, we assume that the PSU (alice) has signed into the FinTechApi and her identity is known to the FinTechApi and thus associated with the service request forwarded to the TppBankingApi.","title":"Step-1: Identify PSU at the FinTechApi"},{"location":"architecture/concepts/psu-security-concept/#step-2-store-psu-idfintech-with-the-consentauthorizationsession","text":"While processing a service request, if the TPP notices that the service request is not covered by a consent (either as a result of pre-checking for the consent or from an error returned by the ASPSP's OpenBankingApi), the TPP will trigger a new consent authorization process identifies by an auth-id and called ConsentAuthorizationSession . Starting a new ConsentAuthorizationSession, we require the TPP to store the FinTech identity of the service requesting PSU alice@fintech with the ConsentAuthorizationSession record before initiating a redirect to the ConsentAuthorisationApi. This is, the ConsentAuthorizationSession record stored in the TPP Database has the state: // Syntax: [index+]=ConsentAuthorizationSession[data] [auth-id,redirectCode]=ConsentAuthorizationSession[auth-id,redirectCode, alice@fintech, ConsentData] // Where redirectCode is a one time key that can be used by the ConsentAuthorisationApi once to retrieve the ConsentAuthorizationSession. // Where auth-id is the identifier of this ConsentAuthorizationSession","title":"Step-2: Store psu-id@fintech with the ConsentAuthorizationSession"},{"location":"architecture/concepts/psu-security-concept/#step-2-identify-psu-at-the-tpp-consentauthorisationapi","text":"At first, redirecting a PSU from the FinTechApi to the TPP ConsentAuthorisationApi does not establish any relationship between the PSU and the TPP, even if we can use the redirectCode associated with the redirected URL to retrieve ConsentAuthorisationSession. Of course the ConsentAuthorisationApi knows that the ConsentAuthorizationSession was initiated by alice@fintech, but this does not mean that the PSU controlling the current PsuUserAgent (known as ConsentAuthorisationUI) is the same natural person as the one controling the identity alice@fintech. In order to proceed with the ConsentAuthorisationSession, the TPP ConsentAuthorisationApi will have to establish an identification of the natural person controlling the UserAgent, resulting in a new PSU identity called (psu-id@tpp). This PSU identity (psu-id@tpp) is associated with the ConsentAuthorisationSession upon successful authentication of the PSU at the TPP ConsentAuthorisationApi interface. At this stage, the ConsentAuthorizationSession record stored in the TPP Database has the following state: [auth-id,redirectCode]=ConsentAuthorizationSession[auth-id,redirectCode, alice@fintech, alice123@tpp, ConsentData] // But with the assumption that alice@fintech =/=> alice123@tpp. // Meaning that both identities are not yet verified equivalent (controlled by the same natural person) Even though the ConsentAuthorizationSession in the TPP database is associated with two identities (alice@fintech and alice123@tpp), there is no proof that both identities alice@fintech and alice123@tpp are controlled by the same natural person.","title":"Step-2: Identify PSU at the TPP ConsentAuthorisationApi"},{"location":"architecture/concepts/psu-security-concept/#step-3a-consentauthorisation-at-the-tpps-consentauthorisationapi-embedded-sca","text":"In an Embedded-SCA case, the credentials associated with psu-id@aspsp are collected by the ConsentAuthorisationApi and forwarded to the OpenBankingApi of the ASPSP. In this case it is easy to assume uniqueness between both psu-id@tpp and psu-id@aspsp as both are done within the same user session at the same interface. This results in the following record after a successful embedded consent authorization at the ConsentAuthorisationApi: [auth-id,redirectCode]=ConsentAuthorizationSession[auth-id,redirectCode, alice@fintech, alice123@tpp, alice-s@aspsp, ConsentData, alice123@tpp==>alice-s@aspsp] // Where alice@fintech =/=> alice123@tpp. // Meaning that both identities are not yet verified equivalent (owned by the same natural person) // Where alice123@tpp ==> alice-s@aspsp. // Meaning alice123@tpp could provide the banking credentials of alice-s@aspsp. Even in this embedded case, there is still a missing equivalence between alice@fintech and alice-s@tpp .","title":"Step-3a: ConsentAuthorisation at the TPP's ConsentAuthorisationApi (Embedded-sca)"},{"location":"architecture/concepts/psu-security-concept/#step-3b-identify-psu-at-the-aspsps-onlinebankingapi-redirect-sca","text":"In a Redirect-SCA case (oauth, redirect, decoupled), the PSU has to be redirected by the ConsentAuthorisationApi to the OnlienBanking interface of the ASPSP. After a successful consent authorization at the OnlienBanking interface, the record could be updated by the mean of poling the authorization status of this ConsentAuthorizationSession at the OpenBankingApi of the ASPSP. Upon successful authorization of the requested consent, the ConsentAuthorizationSession in the database of the TPP looks like: [auth-id,redirectCode]=ConsentAuthorizationSession[auth-id,redirectCode, alice@fintech, alice123@tpp, alice-s@aspsp, ConsentData] // Where alice@fintech =/=> alice123@tpp. // Meaning that both identities are not yet verified equivalent (owned by the same natural person) // Where alice123@tpp =/=> alice-s@aspsp. // Meaning that both identities are not yet verified equivalent (owned by the same natural person)","title":"Step-3b: Identify PSU at the ASPSP's OnlineBankingApi (Redirect-sca)"},{"location":"architecture/concepts/psu-security-concept/#step-4-verify-equivalence-between-psu-idaspsp-and-psu-idtpp-redirect-sca","text":"After a successful consent authorization at the OnlineBankingApi of the ASPSP, the framework has to ensure equivalence between the PSU identified at the TPP and the PSU identified at the ASPSP. In this framework, we designed a two steps redirection FinTech -> TPP -> ASPSP knowing that this might make the process more cumbersome, but this design represents the superset of most of the cases found on the market. After thorough analysis of most scenarios, we noticed that the identity equivalence process can only securely happen in one of these ways:","title":"Step-4: Verify Equivalence between psu-id@aspsp and psu-id@tpp (Redirect-sca)"},{"location":"architecture/concepts/psu-security-concept/#alt-1-sharing-of-identity-provider","text":"If two involved entities (FinTech, TPP, ASPSP) share the same identity provider (IDP), the identity association process will be simple as the IDP will provide a common identifier. For example the subject claim of an identity token could lead to the verification of subject(alice123@tpp)==subject(alice-s@aspsp).","title":"Alt-1: Sharing of Identity Provider"},{"location":"architecture/concepts/psu-security-concept/#alt-2-no-sharing-of-identity-provider","text":"If two parties are not sharing identity provider, a physical back redirection from the ASPSP to the TPP must be used to help complete the identity verification. Note that a physical back redirection will not be possible with the decoupled approach. Following sub-steps will be needed to ensure clean and secure physical back redirection in the example of a redirect from the TPP to the ASPSP:","title":"Alt-2: No Sharing of Identity Provider"},{"location":"architecture/concepts/psu-security-concept/#make-sure-the-physical-back-redirection-sends-the-psu-to-the-source-psuuseragent","text":"The URL for the physical back redirection must have been protected against manipulation: - In case there is an initiation step present between TPP and ASPSP, use this step must have been used to transfer the back redirection url to the ASPSP (this is an example of the redirect approach of the NextGenPSD2 API). - In case there is no such initiation step (generally when OAuth is being used), make sure oAuth2 back redirection url templates and webOrigins are properly designed, as the concrete back redirection url is transported in the redirect_uri parameter of the consent request and exposed to attackers for manipulations.","title":"Make sure the physical back redirection sends the PSU to the Source PsuUserAgent"},{"location":"architecture/concepts/psu-security-concept/#verify-redirect-state-once-in-the-source-psuuseragent","text":"A RedirectCookie must have been set on the PsuUserAgent while redirecting a user from the TPP (ConsentAuthorisationApi) to the ASPSP (OnlineBankingApi). The back redirection url to contains contains the state parameter that is used by the source PsuUserAgent to validate stored RedirectCookie. If a physical redirect can occur from the ASPSP (OnlineBankingApi) back to the TPP (ConsentAuthorisationApi), a validation of the original RedirectCookie can be taken as a guaranty to declare equivalence between the psu-id@tpp and the psu-id@aspsp .","title":"Verify Redirect State once in the Source PsuUserAgent"},{"location":"architecture/concepts/psu-security-concept/#alt-3-no-sharing-of-idp-and-decoupled-sca","text":"We define a decoupled approach as one where there no way of achieving physical (back) redirection between the source UIApp and the target UiApp. This generally happens when both are not on the same physical device. In this case a physical exchange muss happen. This physical information exchange is generally sufficient in one direction as the purpose is to make sure the PSU is physically in control of both devices (and UIApp credentials). Following are among other means for physical information exchange between two devices:","title":"Alt-3: No Sharing of IDP and Decoupled-sca"},{"location":"architecture/concepts/psu-security-concept/#manual-code-transfer","text":"Physical sharing of state information between the source an the target of the redirection can be covered by having one side of the redirect enter a redirectCode displayed by the other side. In this case the redirectCode displayed is the handle for a more complex hash code shared over the back channel between source and target of the redirect.","title":"Manual Code Transfer"},{"location":"architecture/concepts/psu-security-concept/#qr-scan","text":"Physical sharing of state information between the source an the target of the redirection can be covered by having one side of the redirect (camera capable side) the possibility to scan a QR-Code displayed by the other side UIApp.","title":"QR-Scan"},{"location":"architecture/concepts/psu-security-concept/#push-notifications","text":"A push notification could be used to deep link the user into the target decoupled UIApp. To prevent spam, push notification shall only be done if the overall process can provide a sufficient level of confidence that the source side of the redirection identified the PSU before the initiation of the redirection process. The use of push notification can replaces the manual code or QR-scan described above.","title":"Push notifications"},{"location":"architecture/concepts/psu-security-concept/#limitation-of-identity-equivalence-for-existing-openbanking-flows","text":"In some OpenBanking approaches, validating the consent at the OnlineBanking interface of the ASPSP directly finalizes authorization of the service request. The current state of the NextGenPSD2 specification for example finalizes a payment initiation with the act of a PSU authorizing the payment consent (either on the ASPSP or TPP interface), but future release are planing an additional step for the confirmation of the service request at the OpenBanking interface (after authorization). This additional step is necessary for to complete verification of the identity equivalence as described above. Recall that this weakness is only provided if the consent authorizing interface (OnlineBankingApi for redirect-sca or ConsentAuthorizationApi for embedded-sca) can not establish identity equivalence. Remember that if source and target share the same identity provider, target will generally be able establish identity equivalence and therefore authorized payment initiation can be release for execution without breach of the OpenBanking PSU Contract .","title":"Limitation of Identity Equivalence for Existing OpenBanking Flows"},{"location":"architecture/drafts/initial_requirements/","text":"Tech setup Spring Boot >= 2.2 Flowable BPMN 6.x Drools rule engine (embedded with Flowable) Postgres RDBMS 12.x XS2A-flow for tests Least annoying API: TPP creates user profile (name, surname,...) that provides information necessary to perform requests on his behalf TPP provides setting which mode will be used STATIC or DIALOG to perform user requests In STATIC mode TPP must fulfill all fields that are not provided by profile but are necessary to perform action (except SCA) TPP calls i.e. /pay/IBAN-from/IBAN-to/CURRENCY/amount with parameters from step nr. 3. The only extra stuff to complete the call is SCA Initial implementation diagram E2E flows Transaction list flow. Performing payment flow. Generic request handling (Check consent is valid pre-filter) Initially (for MVP0), questions Needs consent? and Consent valid? are answered using database-table that contains bank profile, in future it can be switched to rule engine or entire BPMN job. TPP can initiate consent with PSU under the hood if required. This basically means that if request is missing consent, but has flag to allow automatic consent creation TPP will call obtaining consent flow. Obtaining AIS Consent swimlane Getting transaction list using AIS Consent swimlane Full swimlane e2e for getting transaction list Get transaction list by FinTech **Notes:** 1. Initially PSU enters FinTech screen 'Transaction list' 1. Since consent is missing, when being asked for 'Transaction list' TPP will create implicit consent with PSU (since PSU is in session with FinTech) 1. After consent was established FinTech can store it and get 'Transaction list' without PSU intervention 1. If consent has expired FinTech should inform user and perform step 1 again ![Implementation draft diagram - Tx list full](http://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/adorsys/open-banking-gateway/develop/docs/architecture/drafts/implementation-v0-full-flow-tx-list.puml&fmt=svg&vvv=1&sanitize=true) Full swimlane e2e for performing payment Perform payment by FinTech ![Implementation draft diagram - Perform payment](http://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/adorsys/open-banking-gateway/develop/docs/architecture/drafts/implementation-v0-full-flow-payment.puml&fmt=svg&vvv=2&sanitize=true) API OpenBankingGateway Api is defined for boundary (of course TPP itself can use it): FinTech with OpenBankingGw API <--> TPP with OpenBankingGw Impl (See diagrams above) Consent API: 1. PUT /consents/{bankId} body: {accounts: [<accountIds>], allAccounts: true} to create consent Account information API: 1. GET /transactions to read transactions with option to ask for consent automatically 1. GET /accounts to read account details with option to ask for consent automatically Payment API: 1. PUT /payments to initiate payment ... In short With details API sketch PSU wants to pay 100EUR to IBAN 12345 Generic case Find PSU client bank id GET /api/v1/banks?name=Deutsche or GET /api/v1/banks?bic=12345 -> {bankId} View necessary parameters that are required from PSU for {bankId} to execute payment: GET /api/v1/payments/{bankId}/{psuId}/{ibanFrom}/{ibanTo}/parameters - yields {\"GEO_LOCATION\": \"This payment requires client geo-location\"} (Note: this also may yield i.e. SCA method if PSU did not select it in profile) Since request can't automatically proceed, TPP reads required GEO_LOCATION from PSU Now TPP can proceed with payment PUT /api/v1/payments/{bankId}/{psuId}/{ibanFrom}/{ibanTo} body: {\"amount\": 100.0, \"currency\": \"EUR\", \"GEO_LOCATION\": {\"lat\": 12, \"lng\": 10.0}} (Note: This can have i.e. SCA method to use that overrides profile defaults) OpenBanking handles request sequence using computed process Sequence diagram TPP acquires mandatory parameters before request TPP acquires mandatory parameters during request","title":"Draft"},{"location":"architecture/drafts/initial_requirements/#tech-setup","text":"Spring Boot >= 2.2 Flowable BPMN 6.x Drools rule engine (embedded with Flowable) Postgres RDBMS 12.x XS2A-flow for tests","title":"Tech setup"},{"location":"architecture/drafts/initial_requirements/#least-annoying-api","text":"TPP creates user profile (name, surname,...) that provides information necessary to perform requests on his behalf TPP provides setting which mode will be used STATIC or DIALOG to perform user requests In STATIC mode TPP must fulfill all fields that are not provided by profile but are necessary to perform action (except SCA) TPP calls i.e. /pay/IBAN-from/IBAN-to/CURRENCY/amount with parameters from step nr. 3. The only extra stuff to complete the call is SCA","title":"Least annoying API:"},{"location":"architecture/drafts/initial_requirements/#initial-implementation-diagram","text":"","title":"Initial implementation diagram"},{"location":"architecture/drafts/initial_requirements/#e2e-flows","text":"Transaction list flow. Performing payment flow.","title":"E2E flows"},{"location":"architecture/drafts/initial_requirements/#generic-request-handling-check-consent-is-valid-pre-filter","text":"Initially (for MVP0), questions Needs consent? and Consent valid? are answered using database-table that contains bank profile, in future it can be switched to rule engine or entire BPMN job.","title":"Generic request handling (Check consent is valid pre-filter)"},{"location":"architecture/drafts/initial_requirements/#tpp-can-initiate-consent-with-psu-under-the-hood-if-required","text":"This basically means that if request is missing consent, but has flag to allow automatic consent creation TPP will call obtaining consent flow.","title":"TPP can initiate consent with PSU under the hood if required."},{"location":"architecture/drafts/initial_requirements/#obtaining-ais-consent-swimlane","text":"","title":"Obtaining AIS Consent swimlane"},{"location":"architecture/drafts/initial_requirements/#getting-transaction-list-using-ais-consent-swimlane","text":"","title":"Getting transaction list using AIS Consent swimlane"},{"location":"architecture/drafts/initial_requirements/#full-swimlane-e2e-for-getting-transaction-list","text":"Get transaction list by FinTech **Notes:** 1. Initially PSU enters FinTech screen 'Transaction list' 1. Since consent is missing, when being asked for 'Transaction list' TPP will create implicit consent with PSU (since PSU is in session with FinTech) 1. After consent was established FinTech can store it and get 'Transaction list' without PSU intervention 1. If consent has expired FinTech should inform user and perform step 1 again ![Implementation draft diagram - Tx list full](http://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/adorsys/open-banking-gateway/develop/docs/architecture/drafts/implementation-v0-full-flow-tx-list.puml&fmt=svg&vvv=1&sanitize=true)","title":"Full swimlane e2e for getting transaction list"},{"location":"architecture/drafts/initial_requirements/#full-swimlane-e2e-for-performing-payment","text":"Perform payment by FinTech ![Implementation draft diagram - Perform payment](http://www.plantuml.com/plantuml/proxy?src=https://raw.githubusercontent.com/adorsys/open-banking-gateway/develop/docs/architecture/drafts/implementation-v0-full-flow-payment.puml&fmt=svg&vvv=2&sanitize=true)","title":"Full swimlane e2e for performing payment"},{"location":"architecture/drafts/initial_requirements/#api","text":"OpenBankingGateway Api is defined for boundary (of course TPP itself can use it): FinTech with OpenBankingGw API <--> TPP with OpenBankingGw Impl (See diagrams above) Consent API: 1. PUT /consents/{bankId} body: {accounts: [<accountIds>], allAccounts: true} to create consent Account information API: 1. GET /transactions to read transactions with option to ask for consent automatically 1. GET /accounts to read account details with option to ask for consent automatically Payment API: 1. PUT /payments to initiate payment ...","title":"API"},{"location":"architecture/drafts/initial_requirements/#in-short","text":"","title":"In short"},{"location":"architecture/drafts/initial_requirements/#with-details","text":"","title":"With details"},{"location":"architecture/drafts/initial_requirements/#api-sketch","text":"","title":"API sketch"},{"location":"architecture/drafts/initial_requirements/#psu-wants-to-pay-100eur-to-iban-12345","text":"","title":"PSU wants to pay 100EUR to IBAN 12345"},{"location":"architecture/drafts/initial_requirements/#generic-case","text":"Find PSU client bank id GET /api/v1/banks?name=Deutsche or GET /api/v1/banks?bic=12345 -> {bankId} View necessary parameters that are required from PSU for {bankId} to execute payment: GET /api/v1/payments/{bankId}/{psuId}/{ibanFrom}/{ibanTo}/parameters - yields {\"GEO_LOCATION\": \"This payment requires client geo-location\"} (Note: this also may yield i.e. SCA method if PSU did not select it in profile) Since request can't automatically proceed, TPP reads required GEO_LOCATION from PSU Now TPP can proceed with payment PUT /api/v1/payments/{bankId}/{psuId}/{ibanFrom}/{ibanTo} body: {\"amount\": 100.0, \"currency\": \"EUR\", \"GEO_LOCATION\": {\"lat\": 12, \"lng\": 10.0}} (Note: This can have i.e. SCA method to use that overrides profile defaults) OpenBanking handles request sequence using computed process","title":"Generic case"},{"location":"architecture/drafts/initial_requirements/#sequence-diagram","text":"","title":"Sequence diagram"},{"location":"architecture/drafts/initial_requirements/#tpp-acquires-mandatory-parameters-before-request","text":"","title":"TPP acquires mandatory parameters before request"},{"location":"architecture/drafts/initial_requirements/#tpp-acquires-mandatory-parameters-during-request","text":"","title":"TPP acquires mandatory parameters during request"}]}